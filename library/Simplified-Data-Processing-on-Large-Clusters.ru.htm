<html dir="ltr">
<head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"></meta>
	<meta name="generator" content="ABBYY FineReader 11"></meta>
	<link rel="stylesheet"
				href="Simplified-Data-Processing-on-Large-Clusters_files/Simplified-Data-Processing-on-Large-Clusters.css"
				type="text/css"></link>
</head>
<body dir="ltr">
<p><a name="bookmark0"></a> <span class="font9" style="font-weight:bold">MapReduce: Упрощенная обработка данных на больших кластерах</span>
</p>
<p><a name="bookmark1"></a> <span class="font7">Джеффри Дин и Санджай Ghemawat</span></p>
<p><span class="font4"><a href="mailto:jeff@google.com">jeff@google.com</a> , <a href="mailto:sanjay@google.com">sanjay@google.com</a></span>
</p>
<p>Корпорация Google</p>
<p>Обзор</p>
<p><span class="font6">MapReduce является модель программирования и связанный с ним реализация для обработки и генерации больших наборов данных. </span>Пользователь
	определяет map функцию, которая обрабатывает пары ключ / значение для создания ряда промежуточных пар ключ / значение,
	а также reduce (упрощенную) функцию, которая объединяет все промежуточные значения, связанные с теми же ключевыми
	промежуточными.<span class="font6">Многие реальные задачи выражаются в этой модели, как показано в статье.</span></p>
<p><span class="font6">Программы, написанные на этом функциональном стиле автоматически распараллелить и выполняется на большом кластере товарных машин. </span><span
		class="font6">Во время выполнения система заботится о деталях разделения входных данных, планирование выполнения программы по множеству машин, обработки отказов машин и управления требуемой межмашинные связь. </span><span
		class="font6">Это позволяет программистам без какой-либо опыт работы с параллельными и распределенными системами с легкостью использовать ресурсы большой распределенной системе.</span>
</p>
<p><span class="font6">Наша реализация MapReduce работает на большом кластере товарных машин и отличается высокой масштабируемостью: типичный вычисление MapReduce обрабатывает много терабайт данных на тысячи машин. </span><span
		class="font6">Программисты найти система проста в использовании: сотни программ MapReduce были реализованы и свыше тысяча рабочих мест MapReduce выполняются на кластерах Google, каждый день.</span>
</p>
<p>1. Введение</p>
<p><span class="font6">За последние пять лет, авторы и многие другие в Google реализовали сотни вычислений специального назначения, которые обрабатывают большие объемы исходных данных, таких как просмотренных документов, журналов веб-запрос и т.д., для вычисления различных видов производных данных, таких как перевернутые индексов, различные представления структурой графа веб-документов, резюме количества страниц пополз на хост, множество Наиболее частые запросы в данный день, и т.д. Большинство таких вычисления концептуально проста. </span><span
		class="font6">Тем не менее, ввод данных, как правило, большие, и расчеты должны быть распределены по сотням или тысячам машин, чтобы закончить в разумные сроки. </span><span
		class="font6">Вопросы, как распараллелить вычисления, распространять данные и обработать ошибки в сговор, чтобы скрыть оригинальный простой расчет с большим количеством сложного кода, чтобы заниматься этими вопросами.</span>
</p>
<p><span class="font6">Как реакция на эту сложность, мы разработали новую абстракцию, которая позволяет нам выразить простые вычисления, мы пытались выполнить, но скрывает грязные детали распараллеливания, отказоустойчивости, распределения данных и балансировки нагрузки в библиотеке. </span><span
		class="font6">Наша абстракция вдохновлен <span class="font6" style="font-style:italic">карте</span></span> <span
		class="font6">и</span> <span class="font6" style="font-style:italic">уменьшить</span> <span class="font6">примитивы, присутствующие в Lisp и многих других функциональных языков.</span><span
		class="font6">Мы поняли, что большинство наших вычислений участие применения</span> <span class="font6"
																																															style="font-style:italic">карту</span>
	<span class="font6">операцию по каждой логической &quot;запись&quot; в нашем ввода для вычисления набор пар промежуточных ключ / значение, а затем применять</span>
	<span class="font6" style="font-style:italic">сократить</span> <span class="font6">операцию для всех тех ценностей, которые совместно и тот же ключ, для объединения производные данные надлежащим образом.</span><span
			class="font6">Наше использование функциональной модели с указанной пользователем карте и сократить операции позволяет распараллелить большие вычисления легко и использовать повторное выполнение в качестве основного механизма для обеспечения отказоустойчивости.</span>
</p>
<p><span class="font6">Основным вкладом этой работы является простой и мощный интерфейс, который обеспечивает автоматическое распараллеливание и распределение больших масштабов расчетов, в сочетании с реализацией этого интерфейса, обеспечивающий высокую производительность на больших кластеров товарной ПК.</span>
</p>
<p><span class="font6">Раздел 2 описывает базовую модель программирования и приводит несколько примеров. </span><span
		class="font6">Раздел 3 описывает реализацию интерфейса MapReduce ориентирована на нашем кластера на основе вычислительной среды. </span><span
		class="font6">Раздел 4 описывает несколько уточнений модели программирования, что мы нашли полезным. </span><span
		class="font6">Раздел 5 имеет оценку производительности нашей осуществления для различных задач. </span><span
		class="font6">Раздел 6 исследует использование MapReduce внутри Google, включая нашего опыта в использовании его в качестве основы для переписывания нашей производственной индексации системы. </span><span
		class="font6">Раздел 7 обсуждается связанный и будущей работы.</span></p>
<p>2 Модели программирования</p>
<p><span class="font6">Расчет занимает набор пар</span> <span class="font6" style="font-style:italic">вход</span> <span
		class="font6">ключ / значение, и производит набор</span> <span class="font6">пар</span> <span class="font6"
																																																	style="font-style:italic">выход</span>
	<span class="font6">ключ / значение.</span>Пользователь библиотеки MapReduce выражает расчет как две функции: map и
	Reduc.
</p>
<p><span class="font6" style="font-style:italic">Карта,</span> <span class="font6">написанная пользователем, берет входной пару и производит набор</span>
	<span class="font6">пар</span> <span class="font6" style="font-style:italic">промежуточных</span> <span class="font6">ключ / значение.</span><span
			class="font6">Библиотека MapReduce объединяет все промежуточные значения, связанные с той же промежуточной ключа I и передает их <span
			class="font6">функции</span></span> <span class="font6"><span class="font6"
																																		style="font-style:italic">Reduce.</span></span></p>
<p>Функция Reduce, также написанных пользователем, принимает ключевые промежуточные I и набор значений для этого
	ключа.<span class="font6">Она сливается эти значения в форму по возможности с меньшим набором значений. </span>Обычно
	только ноль или одно выходное значение производится в вызове Reduce.<span class="font6">Промежуточные значения поставляются для снижения функции пользователя с помощью итератора. </span><span
			class="font6">Это позволяет нам обрабатывать списки значений, которые слишком велики, чтобы уместиться в памяти.</span>
</p>
<p><a name="bookmark6"></a> <span class="font8" style="font-weight:bold">2.1 Пример</span></p>
<p><span
		class="font6">Рассмотрим задачу подсчета числа вхождений каждого слова в большом наборе документов. </span><span
		class="font6">Пользователь должен написать код, подобный следующему псевдо-код:</span></p>
<p><span class="font1">map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, &quot;1&quot;); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result));</span>
</p>
<p><span class="font1">/ / Ключ: название документа / / значение: содержание документов для каждого слова ж в стоимости: EmitIntermediate (ш, &quot;1&quot;);</span>
</p>
<p><span class="font1">уменьшение (String ключ, Iterato</span></p>
<p><span class="font1">/ / Ключ: слово / / значения: список рассчитывает десятичного результате = 0; для каждого V в значениях: результат + = ParseInt (объем); Выделяют (AsString (результат));</span>
</p>
<p><span class="font6">Map функция выделяет каждому слову плюс связанный кол-во случаев (только 1 &quot;в этом простом примере). </span><span
		class="font6">Reduce функция суммирует вместе все счетчики связанные с конкретным словом.</span></p>
<p><span class="font6">Кроме того, пользователь пишет код, чтобы заполнить в</span> <span class="font6"
																																													style="font-style:italic">спецификации</span>
	<span class="font6">объекта</span> <span class="font6" style="font-style:italic">MapReduce</span> <span class="font6">с именами входных и выходных файлов и необязательных параметров настройки.</span><span
			class="font6">Затем пользователь вызывает</span> <span class="font6"><span class="font6">функцию</span> <span
			class="font6" style="font-style:italic">MapReduce,</span> передавая ему объект спецификации.</span><span
			class="font6">Пользовательский код связана вместе с библиотекой MapReduce (реализован в C + +). </span><span
			class="font6">Приложение содержит полный текст программы для этого примера.</span></p>
<p><a name="bookmark7"></a> <span class="font8" style="font-weight:bold">2.2 Типы</span></p>
<p><span class="font6">Даже несмотря на предыдущие псевдо-код пишется в терминах строки входа и выхода, концептуально map и reduce функции, введенные пользователем оперируют типами:</span>
</p>
<p><span class="font6">Карта (k1, v1) ^-лист (k2, v2)</span></p>
<p><span class="font6">уменьшить (k2, список (v2)) ^-лист (v2)</span></p>
<p><span class="font6">Т.е., входные ключи и значения взяты из разных доменах выходных ключей и значений. </span><span
		class="font6">Кроме того, промежуточные ключи и значения в том же домене, что и выходных ключей и значений.</span>
</p>
<p><span class="font6">Наша C + + реализация проходит строки и из пользовательских функций и оставляет его в пользовательском коде для преобразования между строками и соответствующих типов.</span>
</p>
<p><a name="bookmark8"></a> <span class="font8" style="font-weight:bold">2.3 Более Примеры</span></p>
<p><span class="font6">Вот несколько простых примеров интересных программ, которые могут быть легко выражены в MapReduce вычислений.</span>
</p>
<p>Распределенная Grep: map функцию выдает линию, если она соответствует образцу.<span class="font6">Функция уменьшения является тождественной функции, что просто копирует поставляется промежуточных данных на выход.</span>
</p>
<p><span class="font6" style="font-weight:bold">Граф URL Access Частота:</span> <span class="font6">Карта функция обрабатывает логи запросов и выходов веб-страницы (URL, 1).</span><span
		class="font6">Функция уменьшения складывает все значения для того же URL и испускает (URL, общее количество) пару.</span>
</p>
<p>Обратный Web-Link График: Выход Map функции</p>
<p><span
		class="font6">(Цель, источник) пары для каждой ссылки на целевой URL, найденного в страницу с именем источника. </span><span
		class="font6">Функция уменьшения объединяет список всех URL-адресов источника, связанного с данной целевой URL и испускает пары:</span>
</p>
<p><span class="font6">(Цель,</span> <span class="font6" style="font-style:italic">список <span class="font6">(источник))</span></span>
</p>
<p><span class="font6" style="font-weight:bold">Срок-Vector в Host:</span> <span class="font6">Термин вектор суммирует наиболее важные слова, которые происходят в документ или комплект документов в виде списка</span>
	<span class="font6" style="font-style:italic">(слово, частота)</span> <span class="font6">пар.</span><span
			class="font6">Карта функция испускает (имя хоста, термин вектор) пару для каждого входного документа (где имя хоста извлекается из URL документа). </span><span
			class="font6">Функция уменьшения передается все за-документа термин векторы для данного хоста. </span><span
			class="font6">Он добавляет эти векторы терминов вместе, выбрасывая редкие термины, а затем испускает окончательное (имя хоста, термин вектор) пару.</span>
</p>
<p><span class="font6" style="font-weight:bold">Перевернутый Индекс:</span> <span class="font6">Карта функция анализирует каждый документ, и выдает последовательность</span>
	<span class="font3">(Word, документ ID)</span> <span class="font6">пар.</span><span class="font6">Функция уменьшения принимает все пары для данного слова, сортирует соответствующие идентификаторы документов и испускает</span>
	<span class="font3">(слово, 1ist (идентификатор документа))</span> <span class="font6">пару.</span><span
			class="font6">Множество всех выходных пар образует простой перевернутый индекс. </span><span class="font6">Легко увеличить это вычисление отслеживать позиции слов.</span>
</p>
<div><img src="Simplified-Data-Processing-on-Large-Clusters_files/Simplified-Data-Processing-on-Large-Clusters-1.jpg"
					style="width:471pt;height:300pt"/>

	<p><span class="font6">Рисунок 1: Обзор выполнения</span></p>
</div>
<br clear="all"/>

<p><span class="font6" style="font-weight:bold">Распределенная Сортировать:</span> <span class="font6">Карта функция извлекает ключ из каждой записи, и испускает</span>
	<span class="font3">(ключ, запись)</span> <span class="font6">пару.</span><span class="font6">Reduce функция выдает все пары без изменений. </span><span
			class="font6">Это вычисление зависит от разделения объектов, описанных в разделе 4.1 и свойств заказа, описанных в разделе 4.2.</span>
</p>
<p>3 Реализация</p>
<p><span class="font6">Множество различных применений интерфейса MapReduce возможны. </span><span class="font6">Правильный выбор зависит от среды. </span><span
		class="font6">Например, одна из реализация может быть подходящей для небольшой разделяемой памятью машины, другой для большого NUMA мультипроцессора, и еще для еще большего коллекцию сетевых машин.</span>
</p>
<p><span class="font6">В этом разделе описывается реализация предназначенная для вычислительной среду в широком использовании в Google:</span>
</p>
<p><span class="font6">больших кластеров товарной ПК, соединенных с Ethernet [4]. </span><span class="font6">В нашей среде:</span>
</p>
<p><span class="font6">(1) Машины, как правило, двумя процессорами x86 c операционной системой Linux, с 2-4 ГБ памяти на машине.</span>
</p>
<p><span class="font6">(2) Товарная сетевого оборудования используется - как правило, либо 100 Мбит / сек или 1 гигабит / сек на уровне компьютера, но в среднем значительно меньше, в общем пропускной деления пополам.</span>
</p>
<p><span class="font6">(3) Кластер состоит из сотен или тысяч машин, и поэтому неудачи машина являются общими.</span>
</p>
<p><span class="font6">(4) Для хранения обеспечивается недорогих дисков IDE, прикрепленных непосредственно на отдельные машины. </span><span
		class="font6">Распределенная файловая система [8] разработана в доме используется для управления данные, хранящиеся на этих дисках. </span><span
		class="font6">Файловая система использует репликацию, чтобы обеспечить доступность и надежность на вершине ненадежного оборудования.</span>
</p>
<p><span class="font6">(5) Пользователи отправляют рабочих мест к системе планирования. </span><span class="font6">Каждое задание состоит из набора задач, и отображается планировщиком к набору доступных машин в кластере.</span>
</p>
<p><a name="bookmark10"></a> <span class="font8" style="font-weight:bold">3.1 Исполнение Обзор</span></p>
<p>Map вызовы распределены между несколькими машинами, автоматически делят входные данные</p>
<p>в последовательность из М частей.<span class="font6">Входные расщепляется могут быть обработаны параллельно на разных машинах. </span><span
		class="font6" style="font-style:italic">Сокращение</span> <span class="font6">вызовы распределяются путем разделения промежуточное пространство ключевую в R куски с помощью функции разбиения (например,</span>
	<span class="font6" style="font-style:italic">хэш (ключ)</span> <span class="font6">мод R).</span><span class="font6">Функция разделения Количество разделов (R) и задаются пользователем.</span>
</p>
<p><span class="font6">На рисунке 1 показан общий поток операции MapReduce в нашей реализации. </span><span
		class="font6">Когда программа пользователя вызывает функцию MapReduce, следующая последовательность действий происходит (пронумерованные этикетки на рисунке 1, соответствуют номерам в списке ниже):</span>
</p>
<p><span class="font6">1    </span><span class="font6">Библиотека MapReduce в программе пользователя сначала разделяет входные файлы в</span>
	<span class="font6" style="font-style:italic">M</span> <span class="font6">кусков типично 16 мегабайт до 64 мегабайт (МБ) за штуку (контролируемых пользователем через необязательного параметра).</span><span
			class="font6">Затем он запускает множество копий программы на кластере машин.</span></p>
<p><span class="font6">2    </span><span class="font6">Одна из копий программы является особенным - мастер. </span><span
		class="font6">Остальные работники, которым назначается работа хозяином. </span>M map задач и R reduce задач
	назначаются.<span
			class="font6">Мастер выбирает незанятых рабочих и присваивает каждому одну из map или reduce задач.</span></p>
<p><span class="font6">3     </span><span class="font6">Работник, который обслуживает map задачe читает содержимое соответствующего куска ввода. </span><span
		class="font6">Он анализирует пары ключ / значение из входных данных и передает каждую пару к пользовательской</span>
	<span class="font6">функции <span class="font6" style="font-style:italic">карты.</span></span><span class="font6">Пары промежуточные ключ / значение, произведенные с помощью <span
			class="font6">функции</span></span> <span class="font6" style="font-style:italic">карты</span> <span
			class="font6">хранятся в буфере в памяти.</span></p>
<p><span class="font6">4    </span>Периодическое, пары из буфера записывается на локальный диск, разбитый на R регионов
	путем функций разделения.<span class="font6">Адреса этих буферных пар на локальном диске, передаются обратно на хозяина, который несет ответственность за передачу этих местах к reduce рабочим.</span>
</p>
<p><span class="font6">5.Трудотерапевты (терапия занятости) и технические/вспомогательные средства    </span><span
		class="font6">Когда сократить рабочий уведомление от хозяина об этих местах, он использует вызовы удаленных процедур для чтения из буфера данные из локальных дисках рабочих карте. </span><span
		class="font6">Когда сократить рабочий прочитал все промежуточные данные, она сортирует его промежуточных ключей, так что все вхождения той же клавише сгруппированы вместе. </span><span
		class="font6">Сортировка необходима, потому что обычно много разных ключей map обрабатываются подобными reduce задачей. </span><span
		class="font6">Если количество промежуточных данных слишком велик, чтобы поместиться в памяти, внешний рода используется.</span>
</p>
<p><span class="font6">6    </span><span class="font6">Сократить рабочие перебирает отсортированных промежуточных данных и для каждого уникального промежуточного ключа столкнулись, он передает ключ и соответствующий набор промежуточных значений для <span
		class="font6" style="font-style:italic">снижения</span></span> <span class="font6">функции <span class="font6">пользователя.</span></span><span
		class="font6">Выход <span class="font6">функции</span></span> <span class="font6"
																																				style="font-style:italic">Reduce</span> <span
		class="font6">добавляется к конечной выходной файл для этого сократить раздел.</span></p>
<p><span class="font6">7 </span><span class="font6">Когда все map задачи и reduce задачи были завершены, мастер пробуждает программу пользователя. </span><span
		class="font6">На данный момент, MapReduce вызов в программе пользователя возвращается в пользовательском коде.</span>
</p>
<p><span class="font6">После успешного завершения, выход за исполнением mapre-дуче доступен в</span> <span
		class="font6"><span class="font6">выходных</span> файлов</span> <span class="font6"
																																					style="font-style:italic">R</span> <span
		class="font6">(по одному на снижения задачу, с именами файлов, как указано пользователем).</span><span
		class="font6">Как правило, пользователям не нужно объединить эти</span> <span class="font6">выходные</span> <span
		class="font6" style="font-style:italic">R</span> <span class="font6">файлов в один файл - они часто проходят эти файлы в качестве вклада в другой MapReduce вызова, или использовать их из другого распределенного приложения, которое в состоянии иметь дело с участием, который поделен на несколько файлов.</span>
</p>
<p>3.2 Структура хозяина данных</p>
<p><span class="font6">Мастер имеет несколько структур данных. </span>Для каждой map задачи и reduce задачи, он
	сохраняет состояние (в режиме ожидания, в производстве, или завершенное), и данные работающей машины (не для простоя
	задач).
</p>
<p><span class="font6">В главной является каналом, через который расположение промежуточных областей файлов распространяется от задач карте, чтобы уменьшить задач. </span><span
		class="font6">Таким образом, за каждый завершенный карте задачи, мастер хранит местоположение и размеры</span> <span
		class="font6" style="font-style:italic">R</span> <span class="font6">промежуточных областях файлов производится карте задачи.</span><span
		class="font6">Обновления для этого места и размер информации получается, которые завершили map задачи. </span><span
		class="font6">Информация была помещена постепенно работникам, которые имеют</span> <span class="font6"
																																														 style="font-style:italic">в незавершенном</span>
	<span class="font6">снизить задач.</span></p>
<p><a name="bookmark12"></a> <span class="font8" style="font-weight:bold">3.3 Отказоустойчивость</span></p>
<p><span class="font6">Поскольку MapReduce библиотека призвана помочь обработать очень большие объемы данных с помощью сотен или тысяч машин, библиотека должна пропускать неудачи машин элегантно.</span>
</p>
<p><a name="bookmark13"></a> <span class="font6" style="font-weight:bold">Работник Невыполнение</span></p>
<p><span class="font6">Мастер пингует каждого работника периодически. </span><span class="font6">Если ответ не будет получен от рабочего в определенный промежуток времени, мастер отмечает работник как не удалось. </span><span
		class="font6">Любые картографических задачи завершены работником сбрасываются обратно в исходное</span> <span
		class="font6">состоянии <span class="font6" style="font-style:italic">ожидания,</span> и, следовательно, получить право на планирование на других работников.</span>Аналогичным
	образом, любая map или reduce задача выполнявшаяся на отказавшем работнике также сбрасывается в ожидание и получает
	право на реструктуризацию.
</p>
<p><span class="font6">Завершенные задачи картографических повторно выполняется на провал, потому что их выход хранится на локальном диске (ы) из строя машины и, следовательно, недоступными. </span><span
		class="font6">Завершенные уменьшить задачи не должны быть повторно выполнена, так как их продукция хранится в глобальной файловой системы.</span>
</p>
<p><span class="font6">Когда карта задание выполнено сначала работнику, а потом казнен работник B (потому не удалось), все работники, выполняющие уменьшить задачи уведомляются о повторного выполнения. </span><span
		class="font6">Некоторые reduce задачи, которые еще не читали данных с работника А будут читать данные из рабочих B.</span>
</p>
<p><span class="font6">MapReduce является устойчивым к крупномасштабных сбоев рабочих. </span><span class="font6">Например, во время одной операции MapReduce, техническое обслуживание сетей на работающем кластере вызывало группы 80 машин за раз, чтобы стать недоступными в течение нескольких минут. </span><span
		class="font6">Мастер MapReduce просто повторно выполнил работу, проделанную недоступных рабочих машин, и продолжал делать продвижение вперед, в конце концов завершения операции MapReduce.</span>
</p>
<p>Отказ Мастера</p>
<p><span class="font6">Это легко сделать мастер периодических создает контрольные точки главной структуры данных, описанной выше. </span><span
		class="font6">Если мастер задача умирает, новая копия может быть запущен из последнего контрольной точки государства. </span><span
		class="font6">Тем не менее, учитывая, что есть только один мастер, его неспособность вряд; поэтому наша текущая реализация прерывает вычисление MapReduce если хозяин не удается. </span><span
		class="font6">Клиенты могут проверить для этого условия, и повторите операцию MapReduce, если они желают.</span></p>
<p>Смысл в наличии отказов</p>
<p><span class="font6">Когда пользователь поставляемых</span> <span class="font6" style="font-style:italic">карта</span>
	<span class="font6">и</span> <span class="font6" style="font-style:italic">снизить</span> <span class="font6">операторы являются детерминированными функциями своих входных значений, наша распределенная реализация дает тот же результат, как бы были произведены не-ошибаясь последовательного выполнения всей программы.</span>
</p>
<p><span class="font6">Мы полагаемся на атомность выхода map и reduce задач для достижения этого свойств. </span><span
		class="font6">Каждая задача незавершенного записывает свой вывод в частных временных файлов. </span><span
		class="font6">Снизить задача производит один такой файл, и карта задача производит R такие файлы (по одному на снижения задачу). </span><span
		class="font6">Когда карта задача завершается, работник посылает сообщение к мастеру и включает в себя имена</span>
	<span class="font6">временных файлов</span> <span class="font6" style="font-style:italic">R</span> <span
			class="font6">в сообщении.</span><span class="font6">Если мастер получает сообщение о уже завершенной map задаче, он игнорирует сообщения. </span><span
			class="font6">В противном случае, он записывает имена</span> <span class="font6">файлов</span> <span class="font6"
																																																					 style="font-style:italic">R</span>
	<span class="font6">в структуре основных данных.</span></p>
<p><span class="font6">Когда снизить задача завершается, сократить рабочий атомно переименовывает свое временное выходной файл до конечного выходного файла. </span><span
		class="font6">Если же уменьшить задание выполнено на нескольких машинах, несколько вызовов переименования будет выполнена по той же конечной выходной файл. </span><span
		class="font6">Мы полагаемся на атомной операции переименования, предоставленной основной файловой системы, чтобы гарантировать, что конечное состояние файловой системы содержит только данные, полученные одним исполнения снижения задачи.</span>
</p>
<p><span class="font6">Подавляющее большинство нашей</span> <span class="font6" style="font-style:italic">карте</span>
	<span class="font6">и</span> <span class="font6" style="font-style:italic">уменьшить</span> <span class="font6">операторов детерминированы, и тот факт, что наши семантика эквивалентны последовательного выполнения в этом случае делает его очень легким для программистов рассуждать о поведении их программы.</span><span
			class="font6">Когда</span> <span class="font6" style="font-style:italic">карта</span> <span
			class="font6">и / или</span> <span class="font6" style="font-style:italic">уменьшить</span> <span class="font6">операторы недетерминированы, мы предоставляем более слабые, но все же разумные семантику.</span><span
			class="font6">В присутствии недетерминированных операторов, выход конкретного снижения задачи Ri эквивалентна выход для Ri производимого последовательном исполнении недетерминистической программы. </span><span
			class="font6">Тем не менее, выход для различных reduce задач может соответствовать выходу для R2 получается с различным последовательным выполнением недетерминистский программы.</span>
</p>
<p><span class="font6">Рассмотрим карту задач M и уменьшить задачи R <sub>1</sub> и R <sub>2.</sub> </span><span
		class="font6">Пусть</span> <span class="font6" style="font-style:italic">е (R <sub>я)</sub></span> <span
		class="font6">быть выполнение</span> <span class="font6"><span class="font6" style="font-style:italic">Ri,</span> что совершил (есть ровно один такой исполнение).</span><span
		class="font6">Возникают слабые семантика, так как е (R <sub>1),</sub> возможно, читали результаты, выданные одной исполнения M и E (R <sub>2),</sub> возможно, читали результаты, выданные другой исполнения</span>
	<span class="font6"><span class="font6" style="font-style:italic">М.</span></span></p>
<p>3.4 Локальность</p>
<p><span class="font6">Пропускная способность сети является относительно дефицитным ресурсом в нашей вычислительной среде. </span><span
		class="font6">Мы сохранения полосы пропускания сети, воспользовавшись тем, что входные данные (управляемые GFS [8]) хранится на локальных дисках машин, которые составляют нашу кластер. </span><span
		class="font6">GFS делит каждый файл на 64 Мб каждый, и хранит несколько копий каждого блока (обычно 3 копии) на разных машинах. </span><span
		class="font6">Мастер MapReduce принимает информацию о местоположении входных файлов во внимание и пытается запланировать карту задачу на компьютере, который содержит реплику соответствующих входных данных. </span><span
		class="font6">В противном случае, он пытается запланировать map задачу вблизи входных данных для этой задачи (например, на рабочую машину, которая находится на той же сетевому коммутаторе как машина, содержащая данные). </span><span
		class="font6">При запуске крупные операции MapReduce на значительной части рабочих в кластере, наиболее входные данные считываются на местном уровне и не потребляет пропускную способность сети.</span>
</p>
<p><a name="bookmark17"></a> <span class="font8" style="font-weight:bold">3.5 Целевая Гранулярность</span></p>
<p><span class="font6">Мы разделить карту фазы в</span> <span class="font6" style="font-style:italic">М</span> <span
		class="font6">кусочки и фазу уменьшить в R куски, как описано выше.</span><span class="font6">В идеале, М и R должны быть значительно больше, чем количество рабочих машин. </span><span
		class="font6">Каждый работник выполняет много разных задач повышает динамическую балансировку нагрузки, а также ускоряет процесс восстановления, когда работник отказывает: много map задач могут быть завершены на всех других машинах работниках.</span>
</p>
<p><span class="font6">Существуют практические ограничения на насколько большой</span> <span class="font6"
																																														 style="font-style:italic">М</span>
	<span class="font6">и</span> <span class="font6" style="font-style:italic">R</span> <span class="font6">может быть в нашей реализации, так как мастер должен сделать</span>
	<span class="font6" style="font-style:italic">O (M</span> <span
			class="font6">+ R) решений по планированию и держит</span> <span class="font6"
																																			 style="font-style:italic">O (M</span> <span
			class="font6">* R) государственной в памяти, как описано выше.</span><span class="font6">(Постоянные факторы для использования памяти маленькие, однако: O (M * R) часть государства состоит из примерно один байт данных в карте задачи / уменьшения пару задач.)</span>
</p>
<p><span class="font6">Кроме того, R часто сдерживается пользователей, поскольку выход каждого снизить задача попадает в отдельный выходной файл. </span><span
		class="font6">На практике мы склонны выбирать M, чтобы каждый задача примерно 16 МБ до 64 МБ входных данных (так что оптимизация местности описано выше является наиболее эффективным), и мы делаем R небольшое кратное числа рабочих машин мы предполагается использовать. </span><span
		class="font6">Мы часто выполняют MapReduce вычислений с М = 200000 и R = 5000, используя 2000 рабочих машин.</span>
</p>
<p>3.6 задачами резервного копирования</p>
<p><span class="font6">Одна из распространенных причин, что удлиняет общее время, необходимое для операции MapReduce является &quot;отставший&quot;: машина, которая занимает необычно долго для завершения одного из последних нескольких карте или уменьшить задачи в вычисления. </span><span
		class="font6">Отставшие могут возникать по целому ряду причин. </span><span class="font6">Например, машина с плохого диска могут возникнуть частые устранимых ошибок, которые замедляют его производительность чтения от 30 Мбит / с до 1 Мб / с. </span><span
		class="font6">Кластерная система планирования может запланировали другие задачи на машине, заставляя его выполнять код MapReduce медленнее из-за конкуренции в ЦП, памяти, локальный диск, или пропускной способности сети. </span><span
		class="font6">Недавнее проблема, которую мы испытали, была ошибка в машинный код инициализации, который вызвал процессор кэши отключен: вычисления на пострадавших машин замедлился более чем на сто раз.</span>
</p>
<p><span class="font6">У нас есть общий механизм, чтобы облегчить проблему отставших. </span>Когда операция MapReduce
	близка к завершению, хозяин планирует резервное выполнение оставшихся текущих задач.<span class="font6">Задача помечается завершенной, когда либо основное или резервное исполнение завершено. </span><span
			class="font6">Мы настроили это механизм, так, что он обычно повышает вычислительные ресурсы, используемые в процессе эксплуатации не более чем на несколько процентов. </span><span
			class="font6">Мы обнаружили, что это значительно сокращает время, чтобы завершить крупные операции MapReduce. </span><span
			class="font6">В качестве примера, программа сортировки описано в разделе 5.3 занимает 44% больше времени, чтобы завершить, когда механизм задание резервного копирования отключена.</span>
</p>
<p><a name="bookmark19"></a> <span class="font8" style="font-weight:bold">4 Уточнения</span></p>
<p><span class="font6">Хотя базовая функциональность путем простого написания</span> <span class="font6"
																																													 style="font-style:italic">Карта</span>
	<span class="font6">и</span> <span class="font6" style="font-style:italic">уменьшить</span> <span class="font6">функции достаточно для большинства нужд, мы нашли несколько расширений полезно.</span><span
			class="font6">Они описаны в данном разделе.</span></p>
<p>4.1 функция дробления</p>
<p><span
		class="font6">Пользователям MapReduce указать количество уменьшить задач / выходных файлов, что они желают (R). </span><span
		class="font6">Данные получает распределяют по всей этих задач, используя функцию разбиения на промежуточном ключа. </span>Функция
	разбиения использует хеширование (например, &quot;hash (Key) MOD R&quot;).<span class="font6">Это обычно приводит к довольно хорошо сбалансированным разделам. </span><span
			class="font6">В некоторых случаях, однако, полезно для деления данных некоторые другие функции ключа. </span><span
			class="font6">Например, иногда выходные ключи URL-адреса, и мы хотим все вхождения для одного хоста, чтобы в конечном итоге в том же выходной файл. </span><span
			class="font6">Для поддержке подобных ситуациях, пользователь библиотеки MapReduce может предоставить специальные функции разбиения. </span><span
			class="font6">Например, с помощью</span> <span class="font6" style="font-style:italic">&quot;хэш (имя хоста (urlkey))</span>
	<span class="font6">мод R&quot;, как функции thepar-titioning вызывает все URL-адреса из того же хозяина, чтобы в конечном итоге в том же выходной файл.</span>
</p>
<p>4.2 Гарантия последовательности</p>
<p><span class="font6">Мы гарантируем, что в пределах данного раздела, пары промежуточные ключ / значение, обрабатываются в увеличении ключевой заказ. </span><span
		class="font6">Эта гарантия упорядочение позволяет легко генерировать отсортированный выходной файл на секцию, которая полезна, когда формат выходного файла должен поддерживать эффективные поисков произвольного доступа по ключу, или пользователи выходе будет удобно иметь данные сортируются.</span>
</p>
<p><a name="bookmark22"></a> <span class="font8" style="font-weight:bold">4.3 Combiner Функция</span></p>
<p><span class="font6">В некоторых случаях, существует значительный повторение в промежуточных ключей, произведенных каждым карте задачи, и указанный пользователем</span>
	<span class="font6" style="font-style:italic">Уменьшите</span> <span class="font6">функцию коммутативна и ассоциативна.</span><span
			class="font6">Хорошим примером этого является слово подсчета пример в разделе 2.1. </span><span class="font6">Поскольку частоты слов имеют тенденцию следовать по распределению Ципфа, каждая map задача будет производить сотни и тысячи записей вида &amp;lt;the, 1&amp;gt;. </span><span
			class="font6">Все эти счетов будет отправлено по сети к одному уменьшить задачи, а затем суммируются</span> <span
			class="font6"><span class="font6">функцией</span> <span class="font6" style="font-style:italic">Reduce,</span> чтобы произвести один ряд.</span>Мы
	позволяем пользователю указать комбинированную функцию что делает частичное слияние этих данных перед их отправкой по
	сети.
</p>
<p>Combiner функция выполняется на каждом компьютере, который выполняет map задачи.<span class="font6">Как правило тот же код используется для реализации как объединитель и снижению функции. </span><span
		class="font6">Единственное различие между функцией уменьшения и функцию сумматора, как библиотека MapReduce обрабатывает выходные данные функции. </span><span
		class="font6">Выходной сигнал уменьшения функции записывается в конечный выходной файл. </span><span class="font6">Выход функции объединителя записывается в промежуточный файл, который будет отправлен к сокращению задачи.</span>
</p>
<p><span class="font6">Частичное объединение значительно ускоряет определенные классы операций MapReduce. </span><span
		class="font6">Приложение А содержит пример, который использует комби.</span></p>
<p>4.4 Входные и выходные типы</p>
<p><span class="font6">Библиотека MapReduce обеспечивает поддержку чтения входных данных в нескольких различных форматах. </span><span
		class="font6">Например, режим ввода &quot;текст&quot; рассматривает каждую строку в виде пары ключ / значение: ключ смещение в файле, и ценность содержимое линии. </span><span
		class="font6">Другой поддерживаемый формат хранения последовательности пар ключ / значение, упорядоченные по ключу. </span><span
		class="font6">Каждая реализация тип входного знает, как разделить себя в значимых диапазонах для обработки как отдельные задачи карте (диапазон расщепления например текстовом режиме гарантирует, что расколы диапазон происходить только в границах линии). </span><span
		class="font6">Пользователи могут добавлять поддержку нового типа входного предоставляя реализацию простого</span>
	<span class="font6">интерфейса <span class="font6" style="font-style:italic">читателя,</span> хотя большинство пользователей просто использовать один из небольшого числа предопределенных типов входных.</span>
</p>
<p><span class="font6" style="font-style:italic"><span class="font6">Читатель</span></span> <span class="font6">не обязательно должны предоставить данные, считанные из файла.</span><span
		class="font6">Например, можно легко определить <span class="font6"><span class="font6" style="font-style:italic">считыватель,</span></span></span>
	<span class="font6">который считывает записи из базы данных или из структур данных, отображенных в памяти.</span></p>
<p><span class="font6">Аналогичным образом, мы поддерживаем множество выходных типов для подготовки данных в различных форматах и удобны для пользователей код для добавления поддержки новых типов вывода.</span>
</p>
<p><a name="bookmark24"></a> <span class="font8" style="font-weight:bold">4.5 Побочные эффекты</span></p>
<p><span class="font6">В некоторых случаях пользователи MapReduce нашли его удобным для производства вспомогательных файлов в качестве дополнительных выходов из их карте и / или уменьшить операторов. </span><span
		class="font6">Мы рассчитываем на применение писателя, чтобы такие побочные эффекты, единичны и идемпотентным. </span><span
		class="font6">Обычно приложение записывает во временный файл и атомно переименовывает этот файл как только он был полностью генерируется.</span>
</p>
<p><span class="font6">Мы не предоставляем поддержку атомных двухфазных фиксаций нескольких выходных файлов, произведенных одной задаче. </span><span
		class="font6">Таким образом, задачи, которые производят несколько выходных файлов с требованиями согласованности кросс-файлов должны быть детерминированным. </span><span
		class="font6">Это ограничение никогда не было проблемой на практике.</span></p>
<p>4.6 Пропуск плохих записей</p>
<p>Иногда бывают ошибки в пользовательском коде, которые вызывают map или reduce функции к краху детерминировано на
	определенных записей.<span class="font6">Такие ошибки предотвратить операцию MapReduce от завершения. </span><span
			class="font6">Обычный курс действий, чтобы исправить ошибку, но иногда это не представляется возможным; возможно, ошибка находится в библиотеке стороннего, для которых исходный код недоступен. </span><span
			class="font6">Кроме того, иногда это приемлемо игнорировать несколько записей, например, когда делать статистический анализ на большом наборе данных. </span><span
			class="font6">Мы предоставляем дополнительный режим исполнения, где находится библиотека MapReduce обнаруживает, которая фиксирует вызвать детерминированных аварий и пропускает эти записи для того, чтобы продвижение вперед.</span>
</p>
<p><span class="font6">Каждый рабочий процесс установки обработчика сигнала, что бросается в нарушении сегментации и ошибок. </span><span
		class="font6">Перед вызовом пользовательского</span> <span class="font6" style="font-style:italic">Карта</span>
	<span class="font6">или</span> <span class="font6" style="font-style:italic">уменьшить</span> <span class="font6">работу, MapRe-дуче хранящая порядковый номер аргумента в глобальной переменной.</span><span
			class="font6">Если код пользователя генерирует сигнал, обработчик сигнала посылает &quot;последнего вздоха&quot; UDP пакет, который содержит порядковый номер к мастеру MapReduce. </span><span
			class="font6">Когда хозяин видел более одного отказа на конкретной записи, это означает, что запись должна быть пропущена, когда он выдает следующую повторное выполнение соответствующей карте или уменьшить задачу.</span>
</p>
<p>4,7 Локальное выполнение</p>
<p><span class="font6">Отладка проблемы в</span> <span class="font6" style="font-style:italic">карте <span
		class="font6">или</span></span> <span class="font6">уменьшить</span> <span class="font6">функции может быть сложно, так как реальное вычисление происходит в распределенной системе, часто на несколько тысяч машин, с решениями присваивания работы, сделанные динамически мастером.</span><span
		class="font6">Чтобы облегчить отладку, профилирование и мелкого тестирование, мы разработали альтернативную реализацию библиотеки MapReduce, что последовательно выполняет все работы для операции MapReduce на локальной машине. </span><span
		class="font6">Элементы управления, предоставляемые пользователю, позволяют вычисления ограничевать конкретными map задачами. </span><span
		class="font6">Пользователи вызвать их программу со специальным флагом и можете легко использовать любые отладки или инструменты тестирования они оказаться полезными (например, GDB).</span>
</p>
<p><a name="bookmark27"></a> <span class="font8" style="font-weight:bold">4.8 Информация о состоянии</span></p>
<p><span class="font6">Мастер запускает внутренний сервер HTTP и публикует набора статуса страницы для потребления человеком. </span><span
		class="font6">Страницы состояния отображают ход вычислений, например, сколько задач были завершены, сколько продолжается, байт ввода, байт промежуточных данных, байт выходных данных, темпы обработки и т.д. На страницах также содержать ссылки на стандартная ошибка и стандартные выходные файлы, порожденная каждой задачи. </span><span
		class="font6">Пользователь может использовать эти данные для предсказать, как долго вычисление состоится, и должны ли быть добавлены дополнительные ресурсы к вычислению. </span><span
		class="font6">Эти страницы также могут быть использованы, чтобы выяснить, когда вычисление происходит гораздо медленнее, чем ожидалось.</span>
</p>
<p><span class="font6">Кроме того, на высшем уровне странице Статус показывает, какие рабочие потерпели неудачу, и какие map и reduce задачи, они обрабатывали, когда они отказали. </span><span
		class="font6">Эта информация полезна при попытке диагностировать ошибки в пользовательском коде.</span></p>
<p>4.9 счетчики</p>
<p><span class="font6">MapReduce библиотека предоставляет счетчики рассчитывать вхождения различных мероприятий. </span><span
		class="font6">Например, код пользователя может потребовать счетчик общего количества слов обрабатываемых или количество немецких документов, индексируемых и т.д.</span>
</p>
<p>Для использования этого объекта, код пользователя создает именованный счетчик объект, а затем увеличивает счетчик
	надлежащим образом в map и / или reduce функции.<span class="font6">Например:</span></p>
<p><span class="font1">Счетчик верхнем регистре;</span></p>
<p><span class="font1">Прописная = GetCounter (&quot;верхний регистр&quot;);</span></p>
<div><img src="Simplified-Data-Processing-on-Large-Clusters_files/Simplified-Data-Processing-on-Large-Clusters-2.png"
					style="width:234pt;height:122pt"/>

	<p><span class="font6">Рисунок 2: Скорость передачи данных в течение долгого времени</span></p>
</div>
<br clear="all"/>

<p><span class="font1">map (string имя, String содержимое): для каждого слова W в разделах: если (IsCapitalized (W)): заглавные-&amp;gt; Increment (); EmitIntermediate (W, &quot;1&quot;);</span>
</p>
<p><span class="font6">Значения счетчика от отдельных машин работников периодически распространяются с помощью мастера (Ping ответ). </span><span
		class="font6">Мастер обрабатывает значения счетчика от успешных map и reduce задач и возвращает их пользователю кода при завершении операции MapReduce. </span><span
		class="font6">Текущие значения счетчиков также отображается на странице мастер состояния, так что человек может наблюдать за ходом живой вычислений. </span><span
		class="font6">При агрегировании значения счетчиков, мастер устраняет последствия дубликатов казни той же карте или уменьшить задачу, чтобы избежать двойного учета. </span><span
		class="font6">(резервного копирования и повторное выполнение задач в связи со сбоями.)</span></p>
<p><span class="font6">Некоторые значения счетчиков автоматически поддерживается библиотеки MapReduce, например, числа пар ввод ключ / значение обработаны и числа пар выходной ключ / значение, производимых.</span>
</p>
<p><span
		class="font6">Пользователи нашли против объекта полезно для проверки поведение операций MapReduce здравомыслия. </span><span
		class="font6">Например, в некоторых операциях MapReduce, код пользователя может потребоваться для того, чтобы количество выходных пар, точно равно числу входных пар обработанных или, что доля немецких документов, обрабатываемых в пределах некоторого допустимого доли от общего количества документов обрабатываются.</span>
</p>
<p><a name="bookmark29"></a> <span class="font8" style="font-weight:bold">5 Производительность</span></p>
<p><span class="font6">В этом разделе мы измеряем производительность MapRe-дуче на двух вычислений, работающих на большом скоплении машин. </span><span
		class="font6">Один вычисление просматривает приблизительно одного терабайта данных, которые ищут определенный шаблон. </span><span
		class="font6">Другой вычисление сортирует приблизительно один терабайт данных.</span></p>
<p><span class="font6">Эти две программы являются представителями большого подмножества реальных программах письменного пользователями MapReduce-один класс программ тасует данные от одного представления к другому, и другой класс извлекает небольшое количество интересных данных из большого набора данных.</span>
</p>
<p><a name="bookmark30"></a> <span class="font8" style="font-weight:bold">5.1 конфигурации кластера</span></p>
<p><span class="font6">Все программы были выполнены на кластере, который состоял из примерно 1800 машин. </span><span
		class="font6">Каждая машина была два процессора 2 ГГц Intel Xeon с Hyper-Threading включена, 4 Гб оперативной памяти, двумя дисками 160 Гб IDE, и ссылку Ethernet гигабитный. </span><span
		class="font6">Машины были расположены в двухуровневой елка форме коммутируемой сети с примерно 100-200 Гбит из совокупной пропускной доступны в корне. </span><span
		class="font6">Все машины были в том же хостинг-объекта и, следовательно, время приема-передачи между любой парой машин было меньше, чем за миллисекунду.</span>
</p>
<p><span
		class="font6">Из 4 Гб оперативной памяти, около 1-1.5GB были защищены для других задач, работающих на кластере. </span><span
		class="font6">Эти программы были выполнены на выходные днем, когда процессоры, диски и сети были в основном простаивает.</span>
</p>
<p><a name="bookmark31"></a> <span class="font8" style="font-weight:bold">5.2 Grep</span></p>
<p>Grep программа просматривает 10 в 10-ой 100 байтовых записей, поиск сравнительно редки трех символьных шаблонов
	(шаблон встречается в 92337 записей).<span class="font6">Входной разделяется на примерно 64 штук (М = 15000), и весь выход размещается в одном файле (R = 1).</span>
</p>
<p><span class="font6">На рисунке 2 показан ход вычислений с течением времени. </span><span class="font6">Y-ось показывает скорость, с которой сканируются входные данные. </span><span
		class="font6">Скорость постепенно набирает больше машин, к этому вычислению MapReduce, и пик более чем в 30 Гб / с когда 1764 рабочие были назначены. </span><span
		class="font6">Как закончить в картографических задач, скорость начинает падать и достигнет нуля около 80 секунд в расчет. </span><span
		class="font6">Весь расчет занимает около 150 секунд от начала до конца. </span><span class="font6">Это включает в себя около минуты накладных расходов автозагрузки. </span><span
		class="font6">Накладные расходы за счет распространения программы на всех рабочих машин, и задержки взаимодействия с GFS, чтобы открыть набор 1000 входных файлов и получить информацию, необходимую для оптимизации местности.</span>
</p>
<p><a name="bookmark32"></a> <span class="font8" style="font-weight:bold">5.3 Сортировка</span></p>
<p><span class="font6"><span class="font6">Программа</span></span> <span class="font5" style="font-style:italic">сортировки</span>
	<span class="font6">сортирует 10 <sup>10</sup> 100 байт записи (примерно 1 терабайта данных).</span><span
			class="font6">Эта программа является образцом теста Benchmark TeraSort [10].</span></p>
<p><span class="font6">Программа сортировки состоит из менее чем 50 строк кода пользователя. </span>Три строки map
	функции выделяют 10-байтовый сортировка ключ из текстовых строк и выдают ключ и исходный текст строки как
	промежуточные пары ключ/значение.
</p>
<p><span class="font6">Подлинный строки текста в кач </span>Мы использовали встроенную тождественную функцию как reduce
	оператор.<span class="font6">Эта функция проходит пара промежуточный ключ / значение неизменным, как пары выход ключ / значение. </span><span
			class="font6">Окончательный отсортированный выходные данные записываются в набор 2-полосных воспроизведены GFS файлов (то есть, 2 терабайта написаны как выход программы).</span>
</p>
<div><img src="Simplified-Data-Processing-on-Large-Clusters_files/Simplified-Data-Processing-on-Large-Clusters-3.jpg"
					style="width:466pt;height:271pt"/>

	<p><span class="font6">Рисунок 3: Скорость передачи данных с течением времени для различных казней программы Упорядочить</span>
	</p>
</div>
<br clear="all"/>

<p>Как и прежде, входные данные разделены на 64MB куски (М = 15000).<span class="font6">Разобьем отсортированный вывод в 4000 файлов (R</span>
	<span class="font5" style="font-style:italic">=</span> <span class="font6">4000).</span><span class="font6">Функция секционирования использует начальные байты ключа для разделения его в один из R штук.</span>
</p>
<p><span
		class="font6">Наша делительная функция для этого теста имеет определенное знание о распределении ключей. </span><span
		class="font6">В общей программы сортировки, мы хотели бы добавить предварительно частот операции MapReduce, что бы собрать образец ключей и использовать распределение отобранных ключей для вычисления сплит-очки для окончательного сортировки проход.</span>
</p>
<p><span class="font6">Рисунок 3 (а) показывает ход нормального выполнения программы сортировки. </span><span
		class="font6">Верхнем левом графике показана скорость, с которой читается вход. </span><span class="font6">Пики скорость, с около 13 Гбайт / с и отмирает довольно быстро, так как все задачи картографических закончить до 200 секунд прошло. </span>Обратите
	внимание, что скорость ввода меньше, чем для Выборки.<span class="font6">Это потому, что вроде картографических задач тратят около половины своего времени и пропускной способности ввода / вывода писать промежуточный вывод в их локальных дисках. </span><span
			class="font6">Соответствующие промежуточные выходы для выборки были незначительным размером.</span></p>
<p><span class="font6">Среднего оставили график показывает скорость, с которой данные передаются по сети с карты задач к снижению задач. </span><span
		class="font6">Это перетасовка начинается, как только первая карта задача завершается. </span><span class="font6">Первый горб на графике для первой партии примерно 1700 уменьшить задачи (весь MapReduce был назначен около 1700 машин, и каждая машина может выполнять не более одного снизить задание за раз). </span><span
		class="font6">Примерно 300 секунд в расчет, некоторые из этих первой партии уменьшить задачи закончить, и мы начинаем перетасовки данных для остальных сократить задач. </span><span
		class="font6">Вся перетасовки делается около 600 секунд в расчет.</span></p>
<p><span class="font6">Нижний левый график показывает скорость, с которой сортируются данные записываются в заключительных выходных файлов по сокращению задач. </span><span
		class="font6">Существует задержка между концом первого периода перетасовки и началом периода пишущего потому что машины заняты сортировки промежуточных данных. </span><span
		class="font6">Запись продолжалась со скоростью около 2-4 Гб / с некоторое время. </span><span class="font6">Все записи закончить около 850 секунд в расчет. </span><span
		class="font6">Включая стартовые накладных расходов, вычисление занимает всего 891 секунд. </span><span
		class="font6">Это похоже на текущий лучший результат 1057 секунд для TeraSort теста [18].</span></p>
<p><span class="font6">Несколько вещей обратить внимание: скорость ввода выше, чем скорость воспроизведения в случайном порядке и размере выходного из-за нашей оптимизации местности - большинство данных считывается с локального диска и обходит нашу относительно пропускной способности ограниченного сети. </span><span
		class="font6">Скорость перемешивания выше, чем скорость вывода, потому что выходной фазы пишет две копии отсортированных данных (сделаем два реплики на выходе для обеспечения надежности и доступности причинам). </span><span
		class="font6">Мы пишем двух реплик, потому что это механизм для надежности и доступности предоставляемых нашей основной файловой системы. </span><span
		class="font6">Требования к пропускной способности сети для записи данных будет снижена, если основной файловой системы используется стирание кодирования [14], а не репликации.</span>
</p>
<p><a name="bookmark33"></a> <span class="font8"
																	 style="font-weight:bold">5.4 Влияние задач резервного копирования</span></p>
<p><span class="font6">На рисунке 3 (б), мы показываем выполнение программы Упорядочить с задачами резервного копирования отключены. </span><span
		class="font6">Поток исполнение аналогично тому, который показан на фиг.3 (а), за исключением того, что существует очень длинный хвост, где происходит едва ли операции записи. </span><span
		class="font6">После 960 секунд, все, кроме 5 reduce задач завершились. </span><span class="font6">Однако за последние несколько отставших не не закончить до 300 секунд позже. </span><span
		class="font6">Вычисление занимает всего 1283 секунд, что на 44% в предыдущем времени.</span></p>
<p><a name="bookmark34"></a> <span class="font8" style="font-weight:bold">5.5 автомат Неудачи</span></p>
<p><span class="font6">На рисунке 3 (C), мы показываем, выполнение программы сортировки, где мы сознательно убили 200 из 1746 рабочих процессов несколько минут в проце. </span><span
		class="font6">Лежащая в основе кластера планировщик сразу перезапустить новые рабочие процессы на этих машинах (так как только процессы были убиты, машины по-прежнему функционирует должным образом).</span>
</p>
<p><span class="font6">Смерти работника показала как отрицательное влияние на скорость ввода, так как некоторым ранее завершеные работы с map пропадали (так были убиты соответствующая рабочая Map) и должно было быть переделано. </span><span
		class="font6">Перевыполнение этой map работы происходит относительно быстро. </span><span class="font6">Весь расчет заканчивается в 933 секунд в том числе запуска накладных расходов (только что на 5% больше, чем в обычное время исполнения).</span>
</p>
<p>6 Опыт</p>
<p><span class="font6">Мы написали первую версию библиотеки MapReduce в феврале 2003 года, и сделал значительные усовершенствования к нему в августе 2003, включая оптимизацию местности, динамической балансировки нагрузки выполнения задачи через рабочих машин и т.д. С тех пор, мы были приятно удивлены тем, насколько широко применима библиотека MapReduce была для видов проблем мы работаем на. </span><span
		class="font6">Он был использован в широком диапазоне областей в пределах Google, в том числе:</span></p>
<p><span class="font6">• масштабные проблемы машинного обучения,</span></p>
<p><span class="font6">• проблемы кластеризации для продуктов Google News и Froogle,</span></p>
<p><span class="font6">• извлечение данных, используемых для составления отчетов популярных запросов (например Google Zeitgeist),</span>
</p>
<p><span class="font6">• добыча свойств веб-страниц для новых экспериментов и продуктов (например добыча географических точках от большого свода веб-страниц для локализованной поиска), и</span>
</p>
<p><span class="font6">• крупномасштабные график вычисления.</span></p>
<img src="Simplified-Data-Processing-on-Large-Clusters_files/Simplified-Data-Processing-on-Large-Clusters-4.png"
		 style="width:219pt;height:187pt"/>

<p><span class="font6">Рисунок 4: экземпляры MapReduce с течением времени</span></p>
<table border="1">
	<tr>
		<td>
			<p><span class="font4">Количество рабочих мест</span></p>
		</td>
		<td>
			<p><span class="font4">29423</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Средний работа Время окончания</span></p>
		</td>
		<td>
			<p><span class="font4">634 сек</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Станки дней используемые</span></p>
		</td>
		<td>
			<p><span class="font4">79186 дней</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Считывание данных входного</span></p>
		</td>
		<td>
			<p><span class="font4">3288 ТБ</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Промежуточные данные, полученные</span></p>
		</td>
		<td>
			<p><span class="font4">758 ТБ</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Выходные данные, записанные</span></p>
		</td>
		<td>
			<p><span class="font4">193 ТБ</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Средний рабочий машины на задание</span></p>
		</td>
		<td>
			<p><span class="font4">157</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Средние показатели смертности рабочих на работу</span></p>
		</td>
		<td>
			<p><span class="font4">1,2</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Средний map задач в работе</span></p>
		</td>
		<td>
			<p><span class="font4">3351</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Средний уменьшить задачи на одно рабочее место</span></p>
		</td>
		<td>
			<p><span class="font4">55 ба</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Уникальные реализации</span> <span class="font4"
																																style="font-style:italic">картографических</span></p>
		</td>
		<td>
			<p><span class="font4">395</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p><span class="font4">Уникальный</span> <span class="font4" style="font-style:italic">снизить</span> <span
					class="font4">реализации</span></p>
		</td>
		<td>
			<p><span class="font4">269</span></p>
		</td>
	</tr>
	<tr>
		<td>
			<p>Уникальная map / сокращение сочетаний</p>
		</td>
		<td>
			<p><span class="font4">426</span></p>
		</td>
	</tr>
</table>
<p><span class="font6">Таблица 1: MapReduce задания выполняются в августе 2004 года</span></p>
<p><span class="font6">Рисунок 4 показывает значительный рост числа отдельных программ MapReduce зарегистрировались в нашем первичной системы управления исходным кодом в течение долгого времени, от 0 в начале 2003 года до почти 900 отдельных случаях по состоянию на конец сентября 2004 года. </span><span
		class="font6">MapReduce оказался настолько успешным, потому что это дает возможность написать простую программу и запустить его эффективно на тысячу машин в ходе полчаса, что значительно ускоряет разработку и прототипирования цикл. </span><span
		class="font6">Кроме того, он позволяет программистам, которые не имеют опыта работы с распределенными и / или параллельных систем использовать большое количество ресурсов легко.</span>
</p>
<p><span class="font6">В конце каждого задания, протоколирует библиотека MapReduce статистика о вычислительных ресурсов, используемых работы. </span><span
		class="font6">В таблице 1 мы показываем некоторые статистические данные для подмножества MapReduce заданий, выполняемых в Google в августе 2004 года.</span>
</p>
<p><a name="bookmark36"></a> <span class="font8" style="font-weight:bold">6.1 Крупномасштабная индексирования</span></p>
<p><span class="font6">Один из наших самых значительных использования MapReduce на сегодняшний день уже полностью переписанный производственной индекса-</span>
</p>
<p><span
		class="font6">ING систему, которая производит структуры данных, используемые для веб-поисковой службы Google. </span><span
		class="font6">Система индексации принимает в качестве входных большой набор документов, загруженных нашим система сканирования, которая хранится в виде набора GFS файлов. </span><span
		class="font6">Сырьевые содержание этих документов более 20 терабайт данных. </span><span class="font6">Процесс индексирования запускается в виде последовательности от пяти до десяти операций MapReduce. </span><span
		class="font6">Использование MapReduce (вместо одноранговой сети распределены проходит в предыдущей версии системы индексации) предоставил несколько преимуществ:</span>
</p>
<p><span class="font6">• Индекс кодирования проще, меньше и легче понять, потому что код, который занимается отказоустойчивости, распределения и распараллеливания скрыт в библиотеке MapReduce. </span><span
		class="font6">Например, размер одной фазы вычисления снизился с примерно 3800 строк C + + кода около 700 линий, когда выражается с помощью MapRe-дуче.</span>
</p>
<p><span class="font6">• Производительность библиотеки MapReduce является достаточно хорошим, что мы можем держать концептуально не связанные вычисления отделить, а смешивая их вместе, чтобы избежать дополнительных проходов по данным. </span><span
		class="font6">Это делает его легко изменить процесс индексирования. </span><span class="font6">Например, одно изменение, что потребовалось несколько месяцев, чтобы сделать в нашей старой системе индексации потребовалось всего несколько дней, чтобы реализовать в новой системе.</span>
</p>
<p><span class="font6">• Процесс индексирования стало намного легче работать, потому что большинство проблем, вызванных отказами машин, медленных машинах, и сетевых икоты рассматриваются автоматически библиотекой MapRe-дуче без вмешательства оператора. </span><span
		class="font6">Кроме того, легко повысить производительность процесса индексации, добавив новые машины к индексации кластера.</span>
</p>
<p><a name="bookmark37"></a> <span class="font8" style="font-weight:bold">7 Связанные работы</span></p>
<p><span class="font6">Многие системы предоставили ограниченные модели программирования и использовали ограничения для автоматического распараллеливания вычислений. </span><span
		class="font6">Например, ассоциативная функция может быть вычислена по всем префиксов</span> <span
		class="font6"><span class="font6">массива</span> элемента</span> <span class="font6"
																																					 style="font-style:italic">N</span> <span
		class="font6">в журнале N времени на процессорах N с помощью параллельных вычислений префикс [6, 9, 13].</span><span
		class="font6">MapReduce можно считать упрощение и перегонка некоторые из этих моделей, основанных на нашем опыте работы с большими реальных вычислений. </span><span
		class="font6">Что еще более важно, мы предоставляем отказоустойчивую реализацию, которая масштабирует до тысяч процессоров. </span><span
		class="font6">В противоположность этому, большинство из параллельных систем обработки только был реализован на меньших масштабах и оставить детали машин обработки ошибок для программиста.</span>
</p>
<p><span class="font6">Массовая Синхронный Программирование [17] и некоторые примитивы MPI [11] обеспечивают абстракции более высокого уровня, что</span>
</p>
<p><span class="font6">сделать его проще для программистам писать параллельные программы. </span><span class="font6">Основное различие между этими системами и MapReduce является то, что MapReduce использует ограниченный модель программирования для автоматического распараллеливания программы пользователя и обеспечить прозрачную отказоустойчивость.</span>
</p>
<p><span class="font6">Наша оптимизация местности черпает свое вдохновение из таких методов, как активных дисков [12, 15], где вычисление проталкивается в процессорных элементов, которые близки к локальным дискам, чтобы уменьшить объем данных, передаваемых через подсистем ввода / вывода или сети. </span><span
		class="font6">Мы бежим на товарных процессоров, к которому небольшое количество дисков непосредственно связанных вместо того, чтобы непосредственно на процессорах дискового контроллера, но общий подход аналогичен.</span>
</p>
<p><span class="font6">Наша резервная механизм задача похожа на нетерпеливого механизма планирования, используемого в Шарлотте системы [3]. </span><span
		class="font6">Один из недостатков простой жадным планирования является то, что, если данная задача вызывает повторяющиеся неудачи, вся вычисление не может завершить. </span><span
		class="font6">Зафиксируем некоторые экземпляры этой задачи с нашей механизма пропуска плохих записей.</span></p>
<p><span class="font6">Реализация MapReduce полагается на системы в доме управления кластера, который отвечает за распространение и запуска задач об большой коллекцией общих машин. </span><span
		class="font6">Хотя это и не в центре внимания данной работы, система управления кластером похож по духу с другими системами, такими как Condor [16].</span>
</p>
<p><span class="font6">Сортировка средство, которое является частью библиотеки MapReduce является в действии подобен СООБЩЕНИЕ сортировки [1]. </span><span
		class="font6">Исходной машины (map работников) раздела данные должны быть отсортированы и направить его в одну из R сокращению рабочих. </span><span
		class="font6">Каждый сократить рабочий сортирует свои данные локально (в памяти, если это возможно). </span><span
		class="font6">Конечно, сейчас сортировки не имеет определяемых пользователем Карта и уменьшить функций, которые делают нашу библиотеку широкое применение.</span>
</p>
<p><span class="font6">River [2] обеспечивает модель программирования, где процессы взаимодействовать друг с другом посредством отправки данных через распределенные очередей. </span><span
		class="font6">Как MapReduce, система реки пытается обеспечить хорошую среднюю производительность случай даже в присутствии неоднородностей, вносимых гетерогенных аппаратных или системных возмущений. </span><span
		class="font6">Река достигает этого путем тщательного планирования дисковых и сетевых трансфертов для достижения сбалансированных время завершения. </span><span
		class="font6">MapRe-дуче имеет другой подход. </span><span class="font6">При ограничении модель программирования, каркас MapReduce может разделить проблему в большом количестве мелкозернистый задач. </span><span
		class="font6">Эти задачи динамически запланированы на имеющихся работников, чтобы быстрее работники обрабатывать несколько задач. </span><span
		class="font6">Ограниченная модель программирования также позволяет нам планировать избыточные выполнение поставленных задач в конце работы, что значительно сокращает время завершения в присутствии неоднородностей (например, медленной или застрявших работников).</span>
</p>
<p><span class="font6">BAD-FS [5] имеет совершенно другой модели программирования от MapReduce, и в отличие от MapReduce, предназначен для выполнения работ по сети на обширной территории. </span><span
		class="font6">Тем не менее, есть два принципиальных сходств. </span><span class="font6">(1) Обе системы используют избыточную выполнение, чтобы оправиться от потери данных, вызванной неудачами. </span><span
		class="font6">(2) Оба используют местонахождение осведомлены планирование, чтобы уменьшить объем данных, передаваемых через перегруженных сетевых соединений.</span>
</p>
<p><span class="font6">TACC [7] является системой, предназначенной для упрощения строительство высоко-доступных сетевых услуг. </span><span
		class="font6">Как MapReduce, он опирается на переоформлении в качестве механизма для реализации отказоустойчивости.</span>
</p>
<p><a name="bookmark38"></a> <span class="font8" style="font-weight:bold">8 Выводы</span></p>
<p><span class="font6">Модель программирования MapReduce успешно используется в Google для различных целей. </span><span
		class="font6">Мы связываем этот успех с несколькими причинами. </span><span class="font6">Во-первых, модель проста в использовании, даже для программистов без опыта работы с параллельных и распределенных систем, так как она скрывает детали распараллеливания, отказоустойчивости, оптимизация местности, и балансировки нагрузки. </span><span
		class="font6">Во-вторых, большое разнообразие проблем легко выражается как MapReduce вычислений. </span><span
		class="font6">Например, MapReduce используется для генерации данных для производства веб-поисковой службы Google, для сортировки, для интеллектуального анализа данных, для машинного обучения, и многих других систем. </span><span
		class="font6">В-третьих, мы разработали реализацию MapReduce, которая масштабируется в больших кластеров машин, содержащих тысячи машин. </span><span
		class="font6">Реализация обеспечивает эффективное использование этих машинных ресурсов и, следовательно, подходит для использования на многих крупных вычислительных задач, возникающих при Google.</span>
</p>
<p><span class="font6">Мы узнали несколько вещей из этой работы. </span><span class="font6">Во-первых, ограничение модель программирования позволяет легко распараллелить и распространять вычисления и сделать такие расчеты отказоустойчивой. </span><span
		class="font6">Во-вторых, пропускная способность сети является дефицитным ресурсом. </span><span class="font6">Ряд оптимизаций в нашей системе, следовательно, направлены на снижение объема данных, переданных по сети: оптимизация местности позволяет нам считать данные из локальных дисках, и писать одну копию промежуточных данных на локальный диск экономит пропускную способность сети. </span><span
		class="font6">В-третьих, излишним выполнение может быть использован для снижения влияния медленных машинах, и обрабатывать отказы машин и потери данных.</span>
</p>
<p>Благодарности</p>
<p><span class="font6">Джош Левенберга играет важную роль в пересмотре и расширении MapReduce API на уровне пользователя с рядом новых функций, основанных на его опыт работы с использованием MapReduce и предложения других людей для усовершенствований. </span><span
		class="font6">MapReduce читает входные данные из и записывает свой вывод в Google File System [8]. </span><span
		class="font6">Мы хотели бы поблагодарить Mohit Aron, Говард Gobioff, Markus Gutschke,</span></p>
<p><span class="font6">Дэвид Крамер, Шун-Так Леунг, и Джош Редстоун за их работу по разработке GFS. Мы также хотели бы поблагодарить Перси Лян и Olcan Sercinoglu за их работу в разработке системы управления кластера, используемого MapReduce. </span><span
		class="font6">Майк Барроуз, Уилсон Се, Джош Левен-берг, Шарон Perl, Роб Пайк, и Дебби Уоллах дали полезные замечания по более ранним проектам данного документа. </span><span
		class="font6">Анонимный OSDI обозревателей, и наш пастырь, Эрик Брюэр, при условии, много полезных предложений районах, где бумага могут быть улучшены. </span><span
		class="font6">Наконец, мы благодарим всех пользователей MapReduce в области инжиниринга организации компании Google за предоставление полезные отзывы, предложения и отчеты об ошибках.</span>
</p>
<p>Ссылки</p>
<p><span class="font4">[1] Андреа С. Arpaci-Dusseau, Ремзи Х. Arpaci-Dusseau, Дэвид Э. Сортировщица, Джозеф М. Hellerstein, и Дэвид А. Паттерсон. </span><span
		class="font4">Высокопроизводительный сортировка по сетям рабочих станций. </span><span class="font4">В</span> <span
		class="font4"
		style="font-style:italic">Трудах 1997 ACM SIGMOD Международной конференции по управлению данными,</span> <span
		class="font4">Тусон, Аризона, мае 1997 года.</span></p>
<p><span class="font4">[2] Ремзи Х. Arpaci-Dusseau, Эрик Андерсон, Ноа Treuhaft, Дэвид Э. Сортировщица, Джозеф М. Hellerstein, Дэвид Паттерсон, и Кэти Yelick. </span><span
		class="font4">Группа I / O с реки: Создание быстро дело общее. </span><span class="font4">В</span> <span
		class="font4" style="font-style:italic">Трудах Шестого совещания по Input / Output в параллельных и распределенных систем (IOPADS &#39;99),</span>
	<span class="font4">страницы 10-22, Атланта, Джорджия, май 1999.</span></p>
<p><span class="font4">[3] Араш Baratloo, Мехмет Караул, Цви Кедем, и Питер Уайкофф. </span><span class="font4">Шарлотта: метакомпьютинг в Интернете. </span><span
		class="font4">В</span> <span class="font4" style="font-style:italic">Трудах 9-й Международной конференции по параллельных и распределенных вычислений Systems,</span>
	<span class="font4">1996.</span></p>
<p><span class="font4">[4] Луис А. Баррозу, Джеффри Дин, и Урс Hölzle. </span><span class="font4">Веб поиск планеты: Архитектура Google кластера. </span><span
		class="font4" style="font-style:italic">IEEE Micro,</span> <span class="font4">23 (2) :22-28, апрель 2003.</span>
</p>
<p><span
		class="font4">[5] Джон Бент, Дуглас Тейн, Андреа C.Arpaci-Dusseau, Ремзи Х. Arpaci-Dusseau, и Мирон Ливны. </span><span
		class="font4">Явное управление в периодическом известно распределенной файловой системы. </span><span class="font4">В</span>
	<span class="font4" style="font-style:italic">Трудах первую USENIX симпозиуме в сетевых системах разработки и осуществления <span
			class="font4">NSDI,</span></span> <span class="font4">март 2004.</span></p>
<p><span class="font4">[6] Гай Е. Blelloch. </span><span
		class="font4">Сканы как примитивных параллельных операций. </span><span class="font4" style="font-style:italic">IEEE Transactions на компьютерах,</span>
	<span class="font4">С-38 (11), ноябрь 1989.</span></p>
<p><span class="font4">[7] Армандо Фокс, Стивен Д. Гриббл, Yatin Chawathe, Эрик А. Брюер, и Пол Готье. </span><span
		class="font4">Кластер на базе масштабируемых сетевых услуг. </span><span class="font4">В</span> <span class="font4"
																																																					style="font-style:italic">Трудах 16 ACM симпозиум на операционной системе <span
		class="font4">принципов,</span></span> <span class="font4">стр. 7891, Сен-Мало, Франция, 1997.</span></p>
<p><span class="font4">[8] Санджай Ghemawat, Говард Gobioff, и Шунь-Так Леунг. </span><span class="font4">Файловая система Google. </span><span
		class="font4">В</span> <span class="font4" style="font-style:italic">19 симпозиума по Операционные системы принципов, на</span>
	<span class="font4">страницах 29-43, Лейк-Джордж, Нью-Йорк, 2003.</span></p>
<p><span class="font4">[9] С. Gorlatch. </span><span class="font4">Систематическое эффективным распараллеливание сканирования и др. Список гомоморфизмов. </span><span
		class="font4">В Л. Bouge, P. Fraigni-AUD, А. Миньотт, и Ю. Роберта, редакторы,</span> <span class="font4"
																																																style="font-style:italic">Евро-Par&#39;96.</span><span
		class="font4" style="font-style:italic">Параллельная обработка,</span> <span class="font4">Лекции в области компьютерных наук 1124, стр. 401-408.</span><span
		class="font4">М.: Мир, 1996.</span></p>
<p><span class="font4">[10] Джим Грей.    </span><span class="font4">Сортировать эталоном домашняя страница. <a
		href="http://research.microsoft.com/barc/SortBenchmark/">http://research.microsoft.com/barc/SortBenchmark/</a> .</span>
</p>
<p><span class="font4">[11] Уильям Gropp, Юинг Ласк, и Энтони Skjellum. </span><span class="font4"
																																										 style="font-style:italic">Использование MPI: Портативный Параллельное программирование с Message-Passing Interface.</span>
	<span class="font4"> </span><span class="font4">MIT Press, Cambridge, MA, 1999.</span></p>
<p><span class="font4">[12] Л. Хьюстон, Р. Sukthankar, Р. Викремесингхе, М. Сатья-Нараянан, GR Ganger, Э. Ридель, А. Ailamaki. </span><span
		class="font4">Алмаз: архитектура хранения для раннего отбрасывания в интерактивном категории. </span><span
		class="font4">В</span> <span class="font4" style="font-style:italic">Трудах 2004 USENIX файл и Storage Technologies БЫСТРЫХ <span
		class="font4">конференции,</span></span> <span class="font4">апрель 2004 года.</span></p>
<p><span class="font4">[13] Ричард Э. Ladner и Майкл Дж. Фишер. </span><span class="font4">Параллельные вычисления префикса. </span><span
		class="font4" style="font-style:italic">Журнал ACM,</span> <span class="font4">27 (4) :831-838, 1980.</span></p>
<p><span class="font4">[14] Майкл О. Рабина. </span><span class="font4">Эффективное рассеивание информации для обеспечения безопасности, балансировки нагрузки и отказоустойчивости. </span><span
		class="font4" style="font-style:italic">Журнал ACM,</span> <span class="font4">36 (2) :335-348, 1989.</span></p>
<p><span class="font4">[15] Эрик Ридель, Христос Faloutsos, Гарт А. Гибсон, и Дэвид Нэглу. </span><span class="font4">Активные диски для обработки крупномасштабных данных. </span><span
		class="font4" style="font-style:italic">IEEE Computer,</span> <span class="font4">стр. 68-74, июнь 2001.</span></p>
<p><span class="font4">[16] Дуглас Тейн, Тодд Танненбаум и Мирон Ливны. </span><span class="font4">Распределенные вычисления на практике: опыт Кондор. </span><span
		class="font4" style="font-style:italic">Параллелизм и Вычисление: практика и <span class="font4">опыт,</span></span>
	<span class="font4">2004.</span></p>
<p><span class="font4">[17] Л. Валиант. </span><span
		class="font4">Мостов модель для параллельных вычислений. </span><span class="font4" style="font-style:italic">Коммуникаций ACM,</span>
	<span class="font4">33 (8) :103-111, 1997 года.</span></p>
<p><span class="font4">[18] Джим Уилли. </span><span class="font4">Spsort: Как сортировать терабайт быстро. <a
		href="http://alme1.almaden.ibm.com/cs/spsort.pdf">http://alme1.almaden.ibm.com/cs/spsort.pdf</a> .</span></p>
<p><a name="bookmark41"></a> <span class="font8" style="font-weight:bold">Слово Частота</span></p>
<p><span class="font6">Этот раздел содержит программу, которая подсчитывает количество вхождений каждого уникального слова в наборе входных файлов, указанных в командной строке.</span>
</p>
<p><span class="font0"># Включить &quot;MapReduce / mapreduce.h&quot;</span></p>
<p><span class="font0">/ / Пользователя карту функция</span></p>
<p><span class="font0">класс WordCounter: общественное Mapper {общественности:</span></p>
<p><span class="font0">виртуальная map Void (сопзЬ MapInput &amp;amp; вход) (Const строки текста &amp;amp; = input.value (); сопзЬ п = text.size (); для (INT I = 0; i &amp;lt;N;) (</span>
</p>
<p><span
		class="font0">/ / Пропустить ведущие пробелы в то время как ((&lt;п) &amp;&amp; isspace (текст [я])) я + +;</span>
</p>
<p><span class="font0">/ / Найти конечную слово десятичного старт = я;</span></p>
<p><span class="font0">в то время как ((&lt;п) &amp;&amp;!</span><span class="font0">isspace (текст [я])) я + +;</span>
</p>
<p><span class="font0">если (начало &lt;я)</span></p>
<p><span class="font0">Выделяют (text.substr (старт, я-старт), &quot;1&quot;);</span></p>
<p><span class="font0">}</span></p>
<p><span class="font0">}</span></p>
<p><span class="font0">};</span></p>
<p><span class="font0">REGISTER_MAPPER (WordCounter);</span></p>
<p><span class="font0">/ / Пользователя сократить функцию класса Adder: общественное Редуктор {</span></p>
<p><span class="font0">виртуальный недействительными Reduce (ReduceInput * вход) {</span></p>
<p><span class="font0">/ / Итерация по всем записям с / / тем же ключом и добавить значения int64 значение = 0; в то время как (!</span><span
		class="font0">ввод-&gt; сделано ()) {</span></p>
<p><span class="font0">значение + = StringToInt (вход-&gt; значение ()); ввод-&gt; NextValue ();</span></p>
<p><span class="font0">}</span></p>
<p><span class="font0">/ / Испустите сумма для ввода-&gt; ключ () Emit (IntToString (значение));</span></p>
<p><span class="font0">}</span></p>
<p><span class="font0">};</span></p>
<p><span class="font0">REGISTER_REDUCER (гадюка);</span></p>
<p><span class="font0">тап_п (внутр агдс, символ ** агду) {ParseCommandLineFlags (агдс, агду);</span></p>
<p><span class="font0">MapReduceSpecification спецификации;</span></p>
<p><span class="font0">Список / / Магазин входных файлов в &quot;спец&quot; для (INT г = 1; я &lt;агдс; я + +) {</span>
</p>
<p><span class="font0">MapReduceInput * вход = spec.add_input (); вход-&gt; set_format (&quot;текст&quot;); вход-&gt; set_filepattern (агду [я]); вход-&gt; set_mapper_class (&quot;WordCounter&quot;);</span>
</p>
<p><span class="font0">}</span></p>
<p><span class="font0">/ / Укажите выходные файлы:</span></p>
<p><span class="font0">/ / / Gfs/test/freq-00000-of-00100 / / / gfs/test/freq-00001-of-00100 / / ...</span></p>
<p><span class="font0">MapReduceOutput * вых = spec.output (); вне&gt; set_filebase (&quot;/ GFS / тест / частота&quot;); вне&gt; set_num_tasks (10 0); вне&gt; set_format (&quot;текст&quot;); вне&gt; set_reducer_class (&quot;Гадюка&quot;);</span>
</p>
<p><span class="font0">/ / Дополнительно: сделать частичные суммы в карте / / задач, чтобы сохранить пропускную способность сети вне&gt; set_combiner_class (&quot;Гадюка&quot;);</span>
</p>
<p><span class="font0">Параметры / / Тюнинг: использовать на большинстве 2000 / / машин и 100 Мб памяти на spec.set_machines задач (2 0 0 0); spec.set_map_megabytes (10 0); spec.set_reduce_megabytes (10 0);</span>
</p>
<p><span class="font0">/ / Теперь запустите его MapReduceResult результат;</span></p>
<p><span class="font0">if (!shaderScript) {</span><span class="font0">MapReduce (спецификации, и результат)) прервать ();</span>
</p>
<p><span class="font0">/ / Урон: &#39;результат&#39; структура содержит информацию / / о счетчиках, время, затраченное, число / / машин используется и т.д.</span>
</p>
<p><span class="font0">return 0;</span></p>
</body>
</html>
