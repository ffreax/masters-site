<!DOCTYPE html>
<!--[if lt IE 8 ]>
<html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>
<html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 8)|!(IE)]><!-->
<html lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>Реферат - Чуприн Владислав</title>
	<meta name="description" content="">
	<meta name="author" content="Vladislav Chuprin">
	<link rel="stylesheet" href="../_css/base.css">
	<link rel="stylesheet" href="../_css/layout.css">
	<link rel="stylesheet" href="../_css/custom.css">
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="js/custom.js"></script>
</head>
<body>
<div id="content-wrap" class="container">
	<style>
		#menu a {
			text-transform: uppercase;
		}
	</style>
	<!-- Header
	================================================== -->
	<header class="container">
		<nav id="nav-wrap" class="cf">
			<ul id="menu">
				<li ><a href="../indexu.htm">Резюме</a></li>
				<li ><a href="../bio/indexu.htm">Біографія</a></li>
				<li class="current"><a href="#">Реферат</a></li>
				<li style="margin-left: 590px"><a href="index.htm"><img src="../_images/ru.png"></a></li>
				<li><a href="../bio/indexe.htm"><img src="../_images/en.png"></a></li>
			</ul>
		</nav>
	</header>

	<article id="page-content" class="container">
		<p><a href="#u1"> Вступ </a> <br/> <a href="#u2">1 </a><a href="#u2">Актуальність теми </a> <br/> <a href="#u3">2. </a><a
				href="#u3">Мета і завдання дослідження, плановані результати </a><br/> <a href="#u4">3. </a><a href="#u4">Огляд
			досліджень і розробок </a><br/> <a href="#u5">3.1 Планувальник в Hadoop</a> <br/> <a href="#u6">3.2 Планувальник
			«Longest Approximate Time to End (LATE)»</a> <br/> <a href="#u7">3.3 Рівномірний планування (FAIR scheduler) [5]</a>
			<br/> <a href="#u8">3.4 Hadoop 2.0. </a><a href="#u8">Capacity scheduler [6]</a> <br/> <a href="#u9">4. </a><a
					href="#u9">Запропонований алгоритм на основі лотерейного планування</a> <br/> <a href="#u10">Висновки</a> <br/> <a
					href="#u11">Список джерел</a> <br/></p> <h3><a name="u1">Вступ</a></h3>

		<p> Hadoop являє собою облачну систему для розподіленої обробки даних, в рамки якої входять завдання, описані відповідно
			до програмної моделі MapReduce. Для невеликих організацій, що використовують Hadoop, характерна наявність
			гетерогенних кластерів з усіх наявних у них ресурсів, а для великих корпоративних систем - наявність величезних
			гомогенних кластерів. Користувачами системи може бути група осіб, які характеризуються такими параметрами як
			пріоритети, зарезервована кількість обчислювальних потужностей, гарантована кількість розділяємого дискового простору
			та інше. Робоче навантаження всередині кластера має бути розподілене між довільною кількістю користувальницьких
			завдань і відповідати безлічі вимог.
		</p>
		<p> Модель програмування. Під час виконання розподіленої обробки на вхід приймаються пари ключ/значення, і генерується
			результуюча множина аналогічних пар. Користувач бібліотеки MapReduce представляє обчислення у вигляді двох фаз: Map і
			Reduce. Map, написана користувачем, отримує на вхід, і створює на виході ключ/значення. Каркас MapReduce групує
			разом всі проміжні результати, отримані на фазі Map, з однаковим проміжним ключем, і передає їх на вхід фазі Reduce.
			Функція Reduce, зазвичай написана користувачем, приймає проміжний ключ і множину значень, пов&#39;язаних з цим ключем,
			здійснюється об&#39;єднання отриманих результатів у імовірно меншу множина значень. Зазвичай, в рамках одного виклику
			Reduce проводиться нуль чи одне вихідне значення. Проміжні значення подаються на вхід Reduce у ітеративному вигляді, що
			дозволяє зберігати списки значень, які є більшими, ніж розмір доступної оперативної пам&#39;яті.
		</p> <h3><a name="u2">1 Актуальність теми</a></h3>
		<p> Планувальники відіграють критичну роль в досягненні нових рівнів продуктивності в системах на базі Hadoop. Важливо
			вибрати відповідний алгоритм планування, враховуючи обмеження, які накладає реалізація Hadoop, зберігаючи прийнятний
			рівень розподіленості.
		</p> <h3><a name="u3">2 Мета і завдання дослідження</a></h3>
		<p> Мета роботи полягає у проведенні порівняльного аналізу існуючих методів планування та розробки концепції
			оптимізованого методу. У рамках роботи, потрібно:
		<ol>
			<li>дослідити реалізацію планувальника в Hadoop;</li>
			<li>проаналізувати існуючі алгоритми планування;</li>
			<li>запропонувати власний підхід на основі вивчених достоїнств і недоліків готових рішень;</li>
		</ol>
		</p>
		<h3><a name="u4">3 Огляд досліджень і розробок</a></h3>
		<p> Основним джерелом, яке розкриває теоритичні основи парадигми MapReduce, можна вважати статтю Jeffrey Dean і
			Sanjay Ghemawat [1]. Реалізація планувальника в рамках Hadoop докладно описана в [3] і є максимально повним джерелом з
			цього питання. Глибокі дослідження підходів до оптимізації наведені в [4-8].
		</p> <h3><a name="u5">3.1 Планувальник в Hadoop</a></h3>
		<p> Реалізація MapReduce в Hadoop відповідає підходу, описаному в [1]. Один головний (master) вузол управляє
			множиною підлеглих (slaves) [2]. Файл з вихідними даними, який знаходиться в розподіленій файловій системі (HDFS), для
			забезпечення відмовостійкості і підвищення продуктивності розбивається на фрагменти (chunk) однакового розміру і
			реплікується із заданим коефіцієнтом дублювання. Hadoop розбиває отримані MapReduce завдання (job) на множину задач
			(task). Кожен фрагмент вхідної інформації обробляється заданою Map функцією. Результати Map фази розбиваються по
			ключу і спрямовуються на вхід фазі Reduce. Схема, наведена в [3] (рис. 1), ілюструє обчислення з використанням підходу
			MapReduce. Hadoop запускає кілька Map і Reduce завдань паралельно на кожному підпорядкованому вузлі -
			по 2 на кожному для перекриття простою CPU і дискової підсистеми. Кожен підлеглий вузол посилає головному вузлу
			повідомлення, коли слоти для обчислення завдань стають порожніми, і тоді планувальник призначає нові завдання вузлів.
			Вбудований в Hadoop планувальник запускає завдання в порядку FIFO з п&#39;ятьма рівнями пріоритетів [3]. Коли слоти
			для виконання завдань звільняються, планувальник сканує наявні завдання в порядку убування пріоритетів, і зберігає
			час, витрачений на пошук необхідної задачі.
		</p> <br/>
		<div style="text-align:center"><img src="../_images/abstract/1.png" align="center"/><br/>
			Малюнок 1. - Схема обчислень MapReduce
		</div> <br/>
		<div style="text-align:center"><img src="../_images/abstract/mapreduce-animation.gif" align="center"/><br/>
			Малюнок 2. - Виконання MapReduce
		</div> <br/>
		<p> Для Map завдань планувальник використовує локальну оптимізацію, реалізовану в Google MapReduce [1]: після вибору
			завдання планувальник розподіляє Map завдання на вузли, що містять максимальну кількість даних для виконання (якщо
			можливо, всі дані повинні знаходиться на обраному вузлі, інакше - на одному з вузлів стійки і, нарешті, на віддаленій
			стійці). Hadoop, використовує резервне копіювання завдань для пом&#39;якшення проблеми гетерогенних кластерів [1].
		</p>
		<p> Планувальник в Hadoop виконує такі неявні припущення:
		<ol>
			<li>Вузли повинні виконувати завдання строго за однаковий час.</li>
			<li>Завдання однаково інтенсивно використовують ресурси протягом усього часу виконання.</li>
			<li>Відсутні витрати на запуск спекулятивних завдань на вузлах, які мають простоюючий слот.</li>
			<li>Відсоток виконання певного завдання цілком відображає розмір виконаної роботи.</li>
			<li>Завдання з поганим прогресом стають відстаючими (strugglers).</li>
			<li>Завдання в одній категорії (Map або Reduce) вимагають однакового обсягу роботи.</li>
		</ol> Припущення 1 і 2 не працюють у віртуальних датацентрах у зв&#39;язку з гетерогенністю. Припущення 3, 4 і 5 можуть не
		працювати у гомогенних дата центрах і приводити до падіння продуктивності Hadoop. Наприклад, для кластерів Yahoo відключено
		спекулятивне виконання деяких завдань, так як це призводить до деградації продуктивності. Facebook також не використовують
		спекуляцію для Reduce завдань [4]. Припущення 6 успадковується з парадигми MapReduce. </p>
		<h3><a name="u6">3.2 Планувальник «Longest Approximate Time to End (LATE)»</a></h3>
		<p> Запропонований спекулятивний планувальник завдань дозволяє частково боротися з наведеними вище недоліками в
			оточеннях з умовами, більш наближеними до реальних. Основна ідея полягає в наступному: «Планувальник зазвичай
			спекулятивно запускає завдання які будуть мати найменшу тривалість виконання, так як ці завдання надають найкращі
			можливості для спекулятивного копіювання для обгону оригінальних завдань та мінімізації часу виконання завдання» [4].
			Інтуїтивно подібна жадібна політика добра, якщо вузли працюють з постійною швидкістю, а також за відсутності витрат
			на запуск спекулятивної завдання на іншому вузлі, який простоює.
		</p>
		<p> Для отримання найкращих шансів на розбиття вихідної задачі на спекулятивні вона повинна запускатися тільки на
			швидких вузлах - не відстаючих (stragglers). Планувальник досягає цього за допомогою простої евристики - не
			відкриваючи завдання на вузлах повільніше деякого порога, загальної виконаної роботи для усіх успішно завершених і
			виконаних завдань на вузлі. Ця евристика дозволяє досягти кращої продуктивності, ніж призначення спекулятивних
			завдань на перший вільний вузол. Інша опція дозволяє створення більш ніж однієї спекулятивної копії кожного завдання,
			однак може витрачати ресурси дарма. Як і планувальник Hadoop, відповідно до запропонованого алгоритму, виконується
			очікування протягом 1 хвилини перед запуском спекулятивної завдання.
		</p> <h3><a name="u7">3.3 Рівномірний планування (FAIR scheduler) [5]</a></h3>
		<p> Порталом Facebook був представлений рівномірний планувальник для розподілення завдань з використанням слотів. Його
			основні ідеї:
		</p>
		<p>
		<ol>
			<li>Ізольованість: створення для всіх користувачів (завдань) ілюзії роботи на абсолютно приватному кластері.</li>
			<li>Статистичний перерозподіл: перерозподіл невикористаних обчислювальних ресурсів від одних користувачів іншим.</li>
		</ol>
		</p>
		<p> Планувальник використовує 2-х рівневу ієрархію. На верхньому рівні, виконується розбиття задач на пули, а на
			нижньому розбиття на слоти ресурсів, виділених під пул, між його завданнями. Варто відзначити, що планувальник в загальному
			випадку може бути узагальнений до довільної кількості рівнів. FAIR використовує ті ж алгоритми для розподілу слотів
			між завданнями пулу, що і планувальник Hadoop для розбиття на вузли [7]. Таким чином, можливі різні модифікації,
			відмінні від FIFO.
		</p> <br/>
		<div style="text-align:center"><img src="../_images/abstract/2.png" align="center"/><br/> Малюнок 3. - Розподіл
			завдань по пулам
		</div> <br/> <h3><a name="u8">3.4 Hadoop 2.0. Capacity scheduler [6]</a></h3>
		<p> Планувальник обчислювальної потужності має деякі спільні риси з рівномірним планувальником, але є і значні
			відмінності. По-перше, планування обчислювальної потужності розраховане на великі кластери, які можуть мати кілька
			незалежних споживачів і кілька цільових додатків. З цієї причини планувальник пропонує розширені можливості
			управління, а також надає гарантовану мінімальну обчислювальну потужність і розділяє надлишки обчислювальної
			потужності між користувачами. При плануванні обчислювальної потужності замість пулів створюються кілька черг, кожна -
			з конфігурованою кількістю слотів для Map і Reduce фаз [7]. Кожній черзі також призначається деяка гарантована
			обчислювальна потужність, при цьому загальна обчислювальна потужність кластера являє собою суму обчислювальних
			потужностей всіх черг. Черги контролюються, і якщо яка-небудь черга не споживає виділену їй обчислювальну потужність,
			надлишки можуть бути тимчасово віддані іншим чергам. З урахуванням того, що черги можуть представляти як фізичних осіб,
			так і великі організації, будь-які вільні обчислювальні ресурси перерозподіляється іншим споживачам.
		</p>
		<h3><a name="u9">4 Запропонований алгоритм на основі лотерейного планування</a></h3>
		<p> В основі алгоритму лежить роздача завданням лотерейних квитків на доступ до обчислювальних ресурсів. Коли
			планувальнику необхідно прийняти рішення, вибирається випадковим чином лотерейний квиток, і його володар отримує право
			запускати свої завдання на вузлах кластера. Більш важливим завданням можна роздати додаткові квитки, щоб збільшити
			ймовірність виграшу.
		</p>
		<p> Лотерейне планування характеризується кількома цікавими властивостями. Наприклад, якщо при постановці в чергу
			завданням дістається кілька квитків, то вже в наступній лотереї його шанси на виграш пропорційні кількості квитків.
			Іншими словами, лотерейне планування має високу чутливість. Завдання одного користувача можуть при необхідності
			обмінюватися квитками. Так, якщо від користувача приходить нове, більш пріоритетне завдання, то частина існуючих
			квитків може бути віддано на його користь.
		</p>
		<p> Лотерейне планування дозволяє вирішувати завдання, які не вирішити за допомогою інших алгоритмів. Як приклад можна
			привести кластер, на якому виконується обробка користувальницьких пошукових запитів. Частина запитів можуть міняти
			свій пріоритет в залежності від уже відправлених, наприклад, з причини незначно відмінності запитуваної інформації.
			Тоді одному із завдань можна видати частину кредитів вже існуючого для оптимізації часу відгуку і деталізувати
			пошукову видачу в момент закінчення менш пріоритетного завдання.
		</p> <h3><a name="u10">Висновки</a></h3>
		<p> Впровадження планувальника, який можна підключати, стало ще одним кроком в еволюції кластерних обчислень з використанням
			системи Hadoop. Підтримка підключаються планувальників дозволяє використовувати (і розробляти) планувальники,
			оптимізовані для конкретного робочого навантаження і конкретного программного забезпечення. Крім того, нові планувальники зробили
			можливим створення багатокористувацьких сховищ даних з використанням системи Hadoop, завдяки забезпеченню можливості
			спільного використання всієї інфраструктури Hadoop декількома користувачами і організаціями.
		</p>
		<p> Система Hadoop розвивається разом з еволюцією її моделей використання і тепер підтримує нові типи робочих навантажень
			і сценаріїв використання (наприклад, великі багатокористувацькі сховища даних і загальні сховища даних для декількох
			організацій). Ці нові гнучкі можливості, які надає Hadoop, є величезним кроком вперед у напрямку більш оптимізованого
			використання кластерних ресурсів при аналізі великих обсягів даних.
		</p> <h3><a name="u11">Список літератури</a></h3>
		<p>
		<ol>
			<li> Dean J. Simplified Data Processing on Large Clusters/J. Dean, S. Ghemawat / / Electronic edition, Google
				Inc., 2004. - 6p
			</li>
			<li> Чуприн В.І. Аналіз проблем безпеки архітектури розподілених NoSQL додатків на прикладі програмного каркаса Hadoop
				/В.І. Чуприн, А.В. Чернишова, Н.Є. Губенко / / Електронне видання, ДонНТУ, 2013. - 356c
			</li>
			<li> Zaharia M. Improving MapReduce Performance in Heterogeneous Environments / M. Zaharia, A. Konwinski, AD
				Joseph, R. Katz, I. Stoica / / Electronic edition, Berkley., 2009. - 14p
			</li>
			<li> Xiao Z. A Hierarchical Approach to Maximizing MapReduce Efficiency / Z. Xiao, H. Chen, B. Zang / / IEEE
				Computer Society., 2011. - 25p
			</li>
			<li> Zaharia M. Improving MapReduce Performance in Heterogeneous Environments / M. Zaharia, A. Konwinski, AD
				Joseph, R. Katz, I. Stoica / / Electronic edition, Berkley., 2009. - 25p
			</li>
			<li> Rasooli A. An Adaptive Scheduling Algorithm for Dynamic Heterogeneous Hadoop Systems / A. Rasooli, DG Down
				/ / Department of Computing and Software McMaster University., 2012. - 35p
			</li>
			<li> Sandholm T. Dynamic Proportional Share Scheduling in Hadoop / T. Sandholm and K. Lai / / Hewlett-Packard
				Laboratories., 2013. - 54p
			</li>
		</ol> </p>

	</article>
</div>
<!-- footer
================================================== -->
<footer class="container">
	<div id="footer-bottom" class="grid12 first" style="text-align: center;">
		<p> 2014 &nbsp; &nbsp; &nbsp; <a href="http://chuprin.pp.ua/">Владислав Чуприн</a></p>
		<div id="go-top" style="display: block;"><a href="#" title="Повернутися угору">Угору</a></div>
	</div>
</footer>

</body>

</html>
