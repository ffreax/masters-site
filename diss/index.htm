<!DOCTYPE html>
<!--[if lt IE 8 ]>
<html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>
<html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 8)|!(IE)]><!-->
<html lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>Реферат - Чуприн Владислав</title>
	<meta name="description" content="">
	<meta name="author" content="Vladislav Chuprin">

	<link rel="stylesheet" href="../_css/base.css">
	<link rel="stylesheet" href="../_css/layout.css">
	<link rel="stylesheet" href="../_css/custom.css">
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="js/custom.js"></script>
</head>

<body>
<div id="content-wrap" class="container">
	<style>
		#menu a {
			text-transform: uppercase;
		}
	</style>
	<!-- Header
	================================================== -->
	<header class="container">
		<nav id="nav-wrap" class="cf">
			<ul id="menu">
				<li ><a href="../index.htm">Резюме</a></li>
				<li ><a href="../bio/index.htm">Биография</a></li>
				<li class="current"><a href="../../content/ru/abstract.html">Реферат</a></li>
				<li ><a href="../library/index.htm">Библиотека</a></li>
				<li ><a href="../links/index.htm">Ссылки</a></li>
				<li ><a href="../report/index.htm">Отчет о поиске</a></li>
				<li ><a href="../ind/index.htm">Индивидуальный раздел</a></li>
				<li><a href="indexu.htm"><img src="../_images/ua.png"></a></li>
				<li><a href="../bio/indexe.htm"><img src="../_images/en.png"></a></li>
			</ul>
		</nav>
	</header>
	<article id="page-content" class="container">
<p>
	<a href="#u1"> Введение </a> <br/>
	<a href="#u2">1. Актуальность темы </a> <br/>
	<a href="#u3">2. Цель и задачи исследования, планируемые результаты </a><br/>
	<a href="#u4">3. Обзор исследований и разработок </a><br/>
	<a href="#u5">3.1 Планировщик в Hadoop</a> <br/>
	<a href="#u6">3.2 Планировщик «Longest Approximate Time to End (LATE)»</a> <br/>
	<a href="#u7">3.3 Равномерное планирование (FAIR scheduler) [5]</a> <br/>
	<a href="#u8">3.4 Hadoop 2.0. Capacity scheduler [6]</a> <br/>
	<a href="#u9">4. Предложенный алгоритм на основе лотерейного планирования</a> <br/>
	<a href="#u10">Выводы</a> <br/>
	<a href="#u11">Список источников</a> <br/>
</p>

<h3><a name="u1">Введение</a></h3>
<p>
	Hadoop представляет собой облачную систему для распределенной обработки данных, в рамках которой
	входящие задания описаны в соответствии с программной моделью MapReduce. Для небольших организаций, использующих
	Hadoop, характерно наличие гетерогенных кластеров из всех имеющихся у них ресурсов, а для больших корпоративных
	систем – наличие огромных гомогенных кластеров. Пользователями системы может быть группа лиц, которые
	характеризуются такими параметрами как приоритеты, зарезервированное количество вычислительных мощностей,
	гарантированное количество разделяемого дискового пространства и прочее. Рабочая нагрузка внутри кластера должна
	быть распределена между произвольным количеством пользовательских заданий и отвечать множеству требований.
</p>
<p>
	Модель программирования. Во время выполнения распределенной обработки на вход принимаются пары ключ/значение, и
	генерируется результирующее множество аналогичных пар. Пользователь библиотеки MapReduce представляет вычисления в
	виде двух фаз: Map и Reduce. Map, написанная пользователем, получает на вход и производит на выходе ключ/значение.
	MapReduce каркас группирует вместе все промежуточные результаты, полученные на фазе Map с одинаковым промежуточным
	ключом, и передает их на вход фазе Reduce. Функция Reduce, обычно написанная пользователем, принимает промежуточный
	ключ и множество значений, связанных с этим ключом, осуществляется объединение полученных результатов в
	предположительно меньшее множество значений. Обычно, в рамках одного вызова Reduce производится ноль и одно выходное
	значение. Промежуточные значения подаются на вход Reduce в итеративном виде, что позволяет хранить списки значений,
	которые являются большими, чем размер доступной оперативной памяти.
</p>
<h3><a name="u2">1 Актуальность темы</a></h3>
<p>
	Планировщики играют критическую роль в достижении новых уровней производительности в системах на базе Hadoop. Важно
	выбрать подходящий алгоритм планирования, учитывая ограничения, которые накладывает реализация Hadoop, сохраняя
	приемлемый уровень распределённости.
</p>
<h3><a name="u3">2 Цель и задачи исследования</a></h3>
<p>
	Цель работы заключается в проведении сравнительного анализа существующих методов планирования и разработке концепции
	оптимизированного метода. В рамках работы, требуется:
	<ol>
	<li>исследовать реализацию планировщика в Hadoop;</li>
	<li>проанализировать существующие алгоритмы планирования;</li>
	<li>предложить собственный подход на основе изученных достоинств и недостатков готовых решений;</li>
	</ol>
</p>
<h3><a name="u4">3 Обзор исследований и разработок</a></h3>
<p>
	Основным источником, раскрывающим теоритические основы парадигмы MapReduce, можно считать статью Jeffrey Dean и
	Sanjay Ghemawat [1]. Реализации планировщика в рамках Hadoop подробно описана в [3] и является максимально полным
	источником по этому вопросу. Глубокие исследования подходов к оптимизации приведены в [4-8].

</p>
<h3><a name="u5">3.1 Планировщик в Hadoop</a></h3>
<p>
	Реализация MapReduce в Hadoop во многом соответствует подходу, описанному в [1]. Один главный
	(master) узел управляет множеством подчиненных (slaves) [2]. Файл с исходными данными, который находится в
	распределенной файловой системе (HDFS), для обеспечения отказоустойчивости и повышения производительности
	разбивается на фрагменты (chunk) одинакового размера и реплицируется с заданным коэффициентом дублирования.
	Hadoop разбивает полученные MapReduce задания (job) на множество задач (task). Каждый фрагмент входной информации
	обрабатывается заданной Map функцией. Выходные значения Map фазы разбиваются по ключу и направляются на вход фазе
	Reduce. Схема, приведенная в [3] (рис. 1), иллюстрирует вычисления с использованием подхода MapReduce.
	Hadoop запускает несколько Map задач и несколько Reduce задач параллельно на каждом подчиненном узле – по 2 на
	каждом для перекрытия простоя CPU и дисковой подсистемы. Каждый подчиненный узел посылает главному узлу сообщение,
	когда слоты для вычисления задач становятся пустыми, и тогда планировщик назначает новые задания узлам. Встроенный в
	Hadoop планировщик запускает задачи в порядке FIFO с пятью уровнями приоритетов [3]. Когда слоты для выполнения
	задач освобождаются, планировщик сканирует имеющиеся задачи в порядке убывания приоритетов, и сохраняет время,
	затраченное на поиск требуемой задачи.
</p>

	<br/>
	<div style="text-align: center">
		<img src="../_images/abstract/1.png" align="center" /><br/>
		Рисунок 1. – Схема вычислений MapReduce
	</div>
	<br/>
<div style="text-align: center">
	<img src="../_images/abstract/mapreduce-animation.gif" align="center" /><br/>
	Рисунок 2. – Выполнение MapReduce
</div>
<br/>

<p>
	Для Map задач планировщик использует локальную оптимизацию, реализованную в Google MapReduce [1]: после выбора
	задания планировщик распределяет Map задачи на узлы, содержащие максимальное количество данных для выполнения (если
	возможно, все данные должны находится на выбранном узле, иначе - на одном из узлов стойки и, наконец, на удаленной
	стойке). Hadoop, использует резервное копирование задач для смягчения проблемы гетерогенных кластеров [1].
</p>

<p>
	Планировщик в Hadoop выполняет следующие неявные предположения:
	<ol>
	<li>Узлы должны выполнять задачи строго за одинаковое время.</li>
	<li>Задачи одинаково интенсивно используют ресурсы на протяжении всего времени выполнения.</li>
	<li>Отсутствуют затраты на запуск спекулятивных задач на узлах, которые имеющих простаивающий слот.</li>
	<li>Процент выполнения определённой задачи целиком отражает размер проделанной работы.</li>
	<li>Задачи с плохим прогрессом становятся отстающими (strugglers).</li>
	<li>Задачи в одной категории (Map или Reduce) требуют одинакового объема работы.</li>
	</ol>
	Предположения 1 и 2 не работают в виртуальных дата - центрах в связи с гетерогенностью. Предположения 3, 4 и 5 могут
	не работать в гомогенных дата центрах и приводить к падению производительности Hadoop. Например, на кластеров Yahoo
	отключено спекулятивное выполнение некоторых задач, так как это приводит к деградации производительности. Facebook
	также не используют спекуляцию для Reduce задач [4]. Предположение 6 наследуется из парадигмы MapReduce.
</p>
<h3><a name="u6">3.2 Планировщик «Longest Approximate Time to End (LATE)»</a></h3>
<p>
	Предложенный спекулятивный планировщик задач позволяет
	частично бороться с приведёнными выше недостатками в окружениях с условиями, более приближенными к реальным.
	Основная идея заключается в следующем: «Планировщик обычно спекулятивно запускает задачи которые будут иметь
	наименьшую продолжительность выполнения, так как эти задачи предоставляют наилучшие возможности для спекулятивного
	копирования для обгона оригинальных задач и минимизации времени выполнения задания» [4]. Интуитивно подобная жадная
	политика хороша, если узлы работают с постоянной скоростью, а также при отсутствии затрат на запуск спекулятивной
	задачи на другом простаивающем узле.
</p>
<p>
	Для получения наилучших шансов на разбиение исходной задачи на спекулятивные она должна запускаться только на
	быстрых узлах – не отстающих (stragglers). Планировщик достигает этого при помощи простой эвристики – не запуская
	задачи на узлах медленнее некоторого порога, общей проделанной работы для всех успешно завершенных и выполняющихся
	задач на узле. Эта эвристика позволяет достичь лучшей производительности, чем назначение спекулятивных задач на
	первый свободный узел. Другая опция позволяет существование более чем одной спекулятивной копии каждой задачи,
	однако может расходовать ресурсы напрасно. Как и планировщик Hadoop, согласно предложенному алгоритму, выполняется
	ожидание на протяжении 1 минуты перед запуском спекулятивной задачи.
</p>

<h3><a name="u7">3.3 Равномерное планирование (FAIR scheduler) [5]</a></h3>
<p>
	Порталом Facebook был представлен равномерный планировщик для
	распределения задач с использованием слотов. Его основные идеи:
</p>
<p>
	<ol>
	<li>Изолированность: создание для всех пользователей (заданий) иллюзии работы на абсолютно приватном кластере.</li>
	<li>Статистическое перераспределение: перераспределение неиспользуемых вычислительных ресурсов от одних пользователей другим.</li>
	</ol>
</p>
<p>
	Планировщик использует 2-х уровневую иерархию. На верхнем уровне, выполняется разбиение задач на пулы, а на нижнем
	разбиение слотов, выделенных под пул, между его задачами. Стоит отметить, что планировщик в общем случае может быть
	обобщён до произвольного количества уровней.
	FAIR использует те же алгоритмы для распределения слотов между задачами пула, что и планировщик Hadoop для разбиения
	на узлы [7]. Таким образом, возможны различные модификации, отличные от FIFO.
</p>

	<br/>
	<div style="text-align: center">
		<img src="../_images/abstract/2.png" align="center"/><br/>
		Рисунок 3. – Распределение заданий по пулам
	</div>
	<br/>
<h3><a name="u8">3.4 Hadoop 2.0. Capacity scheduler [6]</a></h3>
<p>
	Планировщик вычислительной мощности имеет некоторые общие черты с равномерным
	планировщиком, но есть и значительные отличия. Во-первых, планирование вычислительной мощности рассчитано на большие
	кластеры, которые могут иметь несколько независимых потребителей и несколько целевых приложений. По этой причине
	планировщик предлагает расширенные возможности управления, а также предоставляет гарантированную минимальную
	вычислительную мощность и разделяет излишки вычислительной мощности между пользователями. При планировании
	вычислительной мощности вместо пулов создаются несколько очередей, каждая — с конфигурируемым количеством слотов для
	Map и Reduce фаз [7]. Каждой очереди также назначается некоторая гарантированная вычислительная мощность, при этом
	общая вычислительная мощность кластера представляет собой сумму вычислительных мощностей всех очередей. Очереди
	контролируются, и если какая-либо очередь не потребляет выделенную ей вычислительную мощность, излишки могут быть
	временно отданы другим очередям. С учетом того, что очереди могут представлять как физических лиц, так и крупные
	организации, любые свободные вычислительные ресурсы перераспределяется другим потребителям.
</p>

<h3><a name="u9">4 Предложенный алгоритм на основе лотерейного планирования</a></h3>
<p>
	Алгоритм построен на базе аналогичной модели для много процессорніх систем.
	Осноаня идея заключается в раздаче задачам лотерейных билетов на доступ к вычислительным ресурсам.
	В момент принятия решения планировщик выбирает случайным
	образом лотерейный билет, и его обладатель получает право запускать свои задания на узлах кластера. Для увеличения вероятности
	выигрыша более приоритетным
	заданиям можно раздать дополнительные билеты.
</p>
<p>
	Лотерейное планирование отличается высокой отзывчивостью. Например, если при постановке в очередь
	заданию достается несколько билетов, то уже в следующей лотерее его шансы на выигрыш пропорциональны количеству
	билетов.
	Задания одного пользователя могут при необходимости обмениваться билетами. Так, если от пользователя приходит новое,
	более приоритетное задание, то часть существующих билетов может быть отдано в его пользу.
</p>
<p>
	Для некоторых задач лотерейное планирование позволяет находит более гибкие решения. В качестве примера
	можно привести кластер, на котором выполняется обработка пользовательских поисковых запросов. Часть запросов могут
	менять свой приоритет в зависимости от уже отправленных, например, по причине незначительного различия запрашиваемой
	информации. Тогда одному из заданий можно выдать часть кредитов уже существующего для оптимизации времени отклика и
	детализировать поисковую выдачу в момент окончания менее приоритетного задания.
</p>

<h3><a name="u10">Выводы</a></h3>
<p>
	Внедрение подключаемого планировщика стало еще одним шагом в эволюции кластерных вычислений с использованием
	системы Hadoop. Поддержка подключаемых планировщиков позволяет использовать (и разрабатывать) планировщики,
	оптимизированные для конкретной рабочей нагрузки и конкретного приложения. Кроме того, новые планировщики сделали
	возможным создание многопользовательских хранилищ данных с использованием системы Hadoop, благодаря обеспечению
	возможности совместного использования всей инфраструктуры Hadoop несколькими пользователями и организациями.
</p>
<p>
	Система Hadoop развивается по мере эволюции ее моделей использования и теперь поддерживает новые типы рабочих
	нагрузок и сценариев использования (например, большие многопользовательские хранилища данных и общие хранилища
	данных для нескольких организаций). Эти новые гибкие возможности, которые предоставляет Hadoop, являются громадным
	шагом вперед в направлении более оптимизированного использования кластерных ресурсов при анализе больших объемов
	данных.
</p>
<h3><a name="u11">Список литературы</a></h3>
<p>
	<ol>
	<li>
		Dean J. Simplified Data Processing on Large Clusters / J. Dean, S. Ghemawat // Electronic edition, Google
		Inc., 2004. – 6p
	</li>
	<li>
		Чуприн В.И. Анализ проблем безопасности архитектуры распределённых NoSQL приложений на примере программного
		каркаса Hadoop / В.И. Чуприн, А.В. Чернышова, Н.Е. Губенко // Электронное издание, ДонНТУ, 2013. – 356c
	</li>
	<li>
		Zaharia M. Improving MapReduce Performance in Heterogeneous Environments / M. Zaharia, A. Konwinski, A. D.
		Joseph, R. Katz, I. Stoica // Electronic edition, Berkley., 2009. – 14p
	</li>
	<li>
		Xiao Z. A Hierarchical Approach to Maximizing MapReduce Efficiency [Text]/ Z. Xiao, H. Chen, B. Zang // IEEE
		Computer Society., 2011. – 25p
	</li>
	<li>
		Zaharia M. Improving MapReduce Performance in Heterogeneous Environments / M. Zaharia, A. Konwinski, A. D.
		Joseph, R. Katz, I. Stoica // Electronic edition, Berkley., 2009. – 25p
	</li>
	<li>
		Rasooli A. An Adaptive Scheduling Algorithm for Dynamic Heterogeneous Hadoop Systems / A. Rasooli, D. G.
		Down // Department of Computing and Software McMaster University., 2012. – 35p
	</li>
	<li>
		Sandholm T. Dynamic Proportional Share Scheduling in Hadoop / T. Sandholm and K. Lai // Hewlett-Packard
		Laboratories., 2013. – 54p
	</li>
</ol>
</p>
	</article>
</div>
<!-- footer
================================================== -->
<footer class="container">
	<div id="footer-bottom" class="grid12 first" style="text-align: center;">
		<p> 2014 &nbsp; &nbsp; &nbsp; <a href="http://chuprin.pp.ua/">Владислав Чуприн</a></p>
		<div id="go-top" style="display: block;"><a href="#" title="Назад вверх">Ввверх</a></div>
	</div>
</footer>
</body>
</html>
